{"version":3,"sources":["js/main.js"],"names":["get_distance","x1","y1","x2","y2","noise","dx","dy","Math","sqrt","get_line_intersection","p0_x","p0_y","p1_x","p1_y","p2_x","p2_y","p3_x","p3_y","s1_x","s1_y","s2_x","s2_y","s","t","x","y","inteceptCircleLineSeg","cx","cy","cr","p1x","p1y","p2x","p2y","a","b","c","d","u1","u2","ret","retP1","retP2","v1","v2","isNaN","length","canvas","document","getElementById","context","getContext","walls","lineWidth","strokeStyle","fillStyle","scale","translate","turtleState","theta","lidarLength","lidarNoise","lidarMinResolution","turtleMindModel","estimatedTurtlePosition","features","featureDetectionRadius","moveTurtleBy","rotateTurtle","angle","noiseFilter","smoothing","enabled","currentValue","process","pos","newValue","gaussianNoise","value","u","v","random","num","log","cos","PI","positionOverflowingValueFrom","data","maxsize","derivativeOf","offset","result","i","leftPos","rightPos","polarLine","xp","yp","color","xTarget","yTarget","sin","beginPath","moveTo","lineTo","stroke","closePath","renderData","size","shiftOffset","scaleFactor","caption","height","dataPoint","drawXPosition","drawYPositionStart","drawYPositionEnd","save","rotate","textAlign","font","fillText","restore","drawSimulation","clearRect","wall","arc","feature","currentRay","currentFrame","angles","rotationOffset","maxNumScans","rayTargetX","rayTargetY","nearestIntersection","undefined","j","intersection","distance","angleInRadians","wallX","wallY","scanProfileX","scanProfileYEnd","scanProfileYStart","rateOfChanges1st","rateOfChanges2nd","current1stValue","previous1stValue","current2ndValue","featureDetected","featureX","featureY","projectionX","projectionY","featureFound","push","callback","window","requestAnimationFrame","addEventListener","event","key"],"mappings":"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","file":"main.2a83e8e0.js","sourceRoot":"..","sourcesContent":["function get_distance(x1, y1, x2, y2, noise) {\n  var dx = x2 - x1;\n  var dy = y2 - y1;\n  return Math.sqrt(dx *  dx + dy * dy) + noise;\n}\n\nfunction get_line_intersection(p0_x, p0_y, p1_x, p1_y, p2_x, p2_y, p3_x, p3_y)\n{\n  var s1_x, s1_y, s2_x, s2_y;\n  s1_x = p1_x - p0_x;\n  s1_y = p1_y - p0_y;\n  s2_x = p3_x - p2_x;\n  s2_y = p3_y - p2_y;\n\n  var s, t;\n  s = (-s1_y * (p0_x - p2_x) + s1_x * (p0_y - p2_y)) / (-s2_x * s1_y + s1_x * s2_y);\n  t = ( s2_x * (p0_y - p2_y) - s2_y * (p0_x - p2_x)) / (-s2_x * s1_y + s1_x * s2_y);\n\n  if (s >= 0 && s <= 1 && t >= 0 && t <= 1)\n  {\n    return {\n      x: p0_x + (t * s1_x),\n      y: p0_y + (t * s1_y)\n    }\n  }\n\n  return undefined;\n}\n\n// Taken from https://stackoverflow.com/questions/37224912/circle-line-segment-collision/37225895\nfunction inteceptCircleLineSeg(cx, cy, cr, p1x, p1y, p2x, p2y) {\n  var a, b, c, d, u1, u2, ret, retP1, retP2, v1, v2;\n  v1 = {};\n  v2 = {};\n  v1.x = p2x - p1x;\n  v1.y = p2y - p1y;\n  v2.x = p1x - cx;\n  v2.y = p1y - cy;\n  b = (v1.x * v2.x + v1.y * v2.y);\n  c = 2 * (v1.x * v1.x + v1.y * v1.y);\n  b *= -2;\n  d = Math.sqrt(b * b - 2 * c * (v2.x * v2.x + v2.y * v2.y - cr * cr));\n  if (isNaN(d)){ // no intercept\n    return [];\n  }\n  u1 = (b - d) / c;  // these represent the unit distance of point one and two on the line\n  u2 = (b + d) / c;\n  retP1 = {};   // return points\n  retP2 = {}\n  ret = []; // return array\n  if(u1 <= 1 && u1 >= 0){  // add point if on the line segment\n    retP1.x = p1x + v1.x * u1;\n    retP1.y = p2y + v1.y * u1;\n    ret[0] = retP1;\n  }\n  if(u2 <= 1 && u2 >= 0){  // second add point if on the line segment\n    retP2.x = p1x + v1.x * u2;\n    retP2.y = p2y + v1.y * u2;\n    ret[ret.length] = retP2;\n  }\n  return ret;\n}\n\nvar canvas = document.getElementById(\"rendering\");\nvar context = canvas.getContext(\"2d\");\n\nvar walls = [\n  {\n    x1: 0,\n    y1: 0,\n    x2: 150,\n    y2 : 0\n  },\n  {\n    x1: 150,\n    y1: 0,\n    x2: 150,\n    y2 : 100\n  },\n  {\n    x1: 150,\n    y1: 100,\n    x2: 0,\n    y2 : 100\n  },\n  {\n    x1: 0,\n    y1: 0,\n    x2: 0,\n    y2 : 100\n  },\n  {\n    x1: 150,\n    y1: 80,\n    x2: 130,\n    y2 : 80\n  },\n  {\n    x1: 130,\n    y1: 100,\n    x2: 130,\n    y2 : 80\n  },\n];\n\ncontext.lineWidth = 1;\ncontext.strokeStyle = 'black';\ncontext.fillStyle = 'black';\ncontext.scale(2, 2);\ncontext.translate(100, 100);\n\nvar turtleState = {\n  x: 56,\n  y: 56,\n  theta: 0,\n  lidarLength: 100,\n  lidarNoise: 0,\n  lidarMinResolution: 1,\n}\n\nvar turtleMindModel = {\n  estimatedTurtlePosition: {x: 0, y:0, theta: 0},\n  features: [],\n  featureDetectionRadius: 3,\n  moveTurtleBy: function(dx, dy) {\n    this.estimatedTurtlePosition.x += dx;\n    this.estimatedTurtlePosition.y += dy;\n  },\n  rotateTurtle: function(angle) {\n    this.estimatedTurtlePosition.theta += angle;\n  },\n};\n\nvar noiseFilter = {\n  smoothing : 2.5,\n  enabled: false,\n  currentValue: [],\n  process: function(pos, newValue) {\n    if (this.enabled) {\n      if (this.currentValue[pos]) {\n        this.currentValue[pos] += (newValue - this.currentValue[pos]) / this.smoothing;\n        return this.currentValue[pos];\n      } else {\n        this.currentValue[pos] = newValue;\n        return newValue;\n      }\n    } else {\n      return newValue;\n    }\n  }\n}\n\nfunction gaussianNoise(value) {\n  //return (((Math.random() + Math.random() + Math.random() + Math.random()) / 4) - 0.5) * value;\n  let u = 0, v = 0;\n  while(u === 0) u = Math.random(); //Converting [0,1) to (0,1)\n  while(v === 0) v = Math.random();\n  let num = Math.sqrt( -2.0 * Math.log( u ) ) * Math.cos( 2.0 * Math.PI * v );\n  num = num / 10.0 + 0.5; // Translate to 0 -> 1\n  if (num > 1 || num < 0) return gaussianNoise() // resample between 0 and 1\n  return (num - 0.5) * value\n}\n\nfunction positionOverflowingValueFrom(pos, data, maxsize) {\n  if (pos < 0) {\n    pos += maxsize;\n  } else if (pos >= maxsize) {\n    pos -= maxsize;\n  }\n  return data[pos];\n}\n\nvar derivativeOf = function(data,maxsize,offset) {\n  var result = []\n  for (var i = 0; i < maxsize; i++) {\n    var leftPos = positionOverflowingValueFrom(i, data, maxsize);\n    var rightPos = positionOverflowingValueFrom(i + offset, data, maxsize);\n    if (leftPos && rightPos) {\n      result[i] = (rightPos - leftPos);\n    }\n  }\n  return result;\n}\n\nvar polarLine = function(xp, yp, angle, length, color) {\n  var xTarget = xp + Math.cos(Math.PI / 180 * angle) * length;\n  var yTarget = yp + Math.sin(Math.PI / 180 * angle) * length;\n  context.strokeStyle = color;\n  context.fillStyle = color;\n  context.beginPath();\n  context.moveTo(xp, yp);\n  context.lineTo(xTarget, yTarget);\n  context.stroke();\n  context.closePath();\n}\n\nvar renderData = function(xp, yp, color, data, size, shiftOffset, scaleFactor, caption, height) {\n\n  for (var i = 0; i < size; i++) {\n\n    var dataPoint = data[i];\n    if (dataPoint) {\n\n      var drawXPosition = xp + ((i + shiftOffset) % size);\n      var drawYPositionStart = yp;\n      var drawYPositionEnd = drawYPositionStart + dataPoint * scaleFactor;\n\n      context.beginPath();\n      context.strokeStyle = color;\n      context.fillStyle = color;\n\n      context.moveTo(drawXPosition, drawYPositionStart);\n      context.lineTo(drawXPosition, drawYPositionEnd);\n\n      context.stroke();\n      context.closePath();\n    }\n  }\n\n  context.save();\n\n  context.beginPath();\n  context.strokeStyle = 'black';\n  context.fillStyle = 'black';\n\n  context.moveTo(xp, yp - height);\n  context.lineTo(xp, yp + height);\n\n  context.translate(xp, yp);\n  context.rotate(-Math.PI / 2);\n  context.textAlign = 'center';\n  context.font = \"8px Arial\";\n  context.fillText(caption, 0, -5);\n\n  context.stroke();\n  context.closePath();\n\n  context.restore();\n}\n\nvar drawSimulation = function() {\n\n  context.clearRect(-100, -100, 1000, 1000);\n\n  // Render reality\n  context.strokeStyle = 'black';\n  context.fillStyle = 'black';\n  context.textAlign = 'left';\n  context.font = \"8px Arial\";\n  context.fillText('Reality', -20, -20);\n\n  // Draw the walls\n  context.strokeStyle = 'black';\n  context.fillStyle = 'black';\n  context.beginPath();\n  for (i = 0; i < walls.length; i++) {\n    var wall = walls[i];\n    context.moveTo(wall.x1, wall.y1);\n    context.lineTo(wall.x2, wall.y2);\n  }\n  context.stroke();\n  context.closePath();\n\n  // Draw the turtle\n  context.beginPath();\n  context.strokeStyle = 'gray';\n  context.fillStyle = 'gray';\n  context.arc(turtleState.x, turtleState.y, 8, 0, 2 * Math.PI);\n  context.stroke();\n  context.closePath();\n\n  polarLine(turtleState.x, turtleState.y, turtleState.theta, 20, 'green');\n\n  // Render turtles model\n  context.strokeStyle = 'black';\n  context.fillStyle = 'black';\n  context.textAlign = 'left';\n  context.font = \"8px Arial\";\n  context.fillText('Turtles model no.F. = ' + turtleMindModel.features.length, -20, 120);\n\n  context.beginPath();\n  context.strokeStyle = 'gray';\n  context.fillStyle = 'gray';\n  context.arc(turtleMindModel.estimatedTurtlePosition.x + 56, turtleMindModel.estimatedTurtlePosition.y + 200, 8, 0, 2 * Math.PI);\n  context.stroke();\n  context.closePath();\n\n  polarLine(turtleMindModel.estimatedTurtlePosition.x + 56, turtleMindModel.estimatedTurtlePosition.y + 200, turtleMindModel.estimatedTurtlePosition.theta, 20, 'green');\n\n  for (var i = 0; i < turtleMindModel.features.length; i++) {\n    var feature = turtleMindModel.features[i];\n    context.beginPath();\n    context.strokeStyle = 'black';\n    context.fillStyle = 'black';\n    context.arc(feature.x - 1 + 56, feature.y -1 + 200, 3, 0, 2 * Math.PI);\n    context.stroke();\n    context.closePath();\n\n  }\n\n  var currentRay = 0;\n  var currentFrame = [];\n  var angles = [];\n\n  var maxNumScans = 360 / turtleState.lidarMinResolution;\n  var rotationOffset = maxNumScans / 2;\n\n  for (var i = turtleState.theta; i < turtleState.theta + 360; i += turtleState.lidarMinResolution, currentRay++) {\n    var rayTargetX = turtleState.x + Math.cos(Math.PI / 180 * i) * turtleState.lidarLength;\n    var rayTargetY = turtleState.y + Math.sin(Math.PI / 180 * i) * turtleState.lidarLength;\n\n    var nearestIntersection = undefined;\n    for (var j = 0; j < walls.length; j++) {\n      var wall = walls[j];\n\n      var intersection = get_line_intersection(turtleState.x, turtleState.y, rayTargetX, rayTargetY, wall.x1, wall.y1, wall.x2, wall.y2);\n      if (intersection) {\n        var distance = noiseFilter.process(currentRay, get_distance(turtleState.x, turtleState.y, intersection.x, intersection.y, gaussianNoise(turtleState.lidarNoise)));\n        if (nearestIntersection) {\n          if (nearestIntersection.distance > distance) {\n            nearestIntersection = {\n              distance: distance,\n              intersection: intersection\n            };\n          }\n        } else {\n          nearestIntersection = {\n            distance: distance,\n            intersection: intersection\n          }\n        }\n      }\n    }\n\n    if (nearestIntersection) {\n\n      currentFrame[currentRay] = nearestIntersection.distance;\n      angles[currentRay] = i;\n\n      // Do some back projection\n      var angleInRadians = Math.PI / 180 * i;\n      var wallX = turtleState.x + Math.cos(angleInRadians) * nearestIntersection.distance;\n      var wallY = turtleState.y + Math.sin(angleInRadians) * nearestIntersection.distance;\n\n      context.beginPath();\n      context.strokeStyle = 'CadetBlue';\n      context.fillStyle = 'CadetBlue';\n      context.arc(wallX, wallY, 2, 0, 2 * Math.PI);\n      context.stroke();\n      context.closePath();\n\n      context.beginPath();\n      if (currentRay === 0) {\n        context.strokeStyle = 'green';\n        context.fillStyle = 'green';\n      } else {\n        context.strokeStyle = 'CadetBlue';\n        context.fillStyle = 'CadetBlue';\n      }\n\n      var scanProfileX = 200 + ((currentRay + rotationOffset) % maxNumScans);\n      var scanProfileYStart = 50;\n      var scanProfileYEnd = scanProfileYStart - nearestIntersection.distance;\n\n      context.moveTo(scanProfileX, scanProfileYStart);\n      context.lineTo(scanProfileX, scanProfileYEnd);\n\n      context.stroke();\n      context.closePath();\n\n    } else {\n      context.strokeStyle = 'rgba(128,128,128,0.05)';\n      context.fillStyle = 'rgba(128,128,128,0.05)';\n      context.beginPath();\n      context.moveTo(turtleState.x, turtleState.y);\n      context.lineTo(rayTargetX, rayTargetY);\n      context.stroke();\n      context.closePath();\n    }\n  }\n\n  context.save();\n  context.beginPath();\n  context.strokeStyle = 'black';\n  context.fillStyle = 'black';\n  context.moveTo(200, 50);\n  context.lineTo(200, 50 - 120);\n  context.translate(200, 50);\n  context.rotate(-Math.PI / 2);\n  context.textAlign = 'center';\n  context.font = \"8px Arial\";\n  context.fillText('Lidar distance', 60, -5);\n  context.stroke();\n  context.closePath();\n  context.restore();\n\n  var rateOfChanges1st = derivativeOf(currentFrame, currentRay, 1);\n  var rateOfChanges2nd = derivativeOf(rateOfChanges1st, currentRay, 1);\n\n  var maxNumScans = 360 / turtleState.lidarMinResolution;\n  var rotationOffset = maxNumScans / 2;\n\n  // Render derivatives\n  renderData(200, 90, 'DarkSlateGrey', rateOfChanges1st, maxNumScans, rotationOffset, 3, '1st derivative', 20);\n  renderData(200, 160, 'DarkSlateGrey', rateOfChanges2nd, maxNumScans, rotationOffset, 15, '2nd derivative',20);\n\n  // Check for maxima and sharp edges\n  for (var i = 0; i < currentRay; i++) {\n    var current1stValue = positionOverflowingValueFrom(i, rateOfChanges1st, maxNumScans);\n    var previous1stValue = positionOverflowingValueFrom(i - 1, rateOfChanges1st, maxNumScans);\n\n    var current2ndValue = positionOverflowingValueFrom(i, rateOfChanges2nd, maxNumScans);\n\n    var featureDetected = false;\n    if (current1stValue && previous1stValue && current2ndValue) {\n      if (previous1stValue >= 0 && current1stValue < 0) {\n        // Farest point, maxima in lidar data\n        featureDetected = true;\n      } else if (previous1stValue < 0 && current1stValue > 0.025) {\n        // Sharp edge\n        featureDetected = true;\n      }\n    }\n    var distance = currentFrame[i];\n    if (featureDetected && distance) {\n\n      var angle = angles[i];\n      var angleInRadians = Math.PI / 180 * angle;\n      var featureX = turtleState.x + Math.cos(angleInRadians) * distance;\n      var featureY = turtleState.y + Math.sin(angleInRadians) * distance;\n\n      // Mark Feature on the Map\n      context.beginPath();\n      context.strokeStyle = 'red';\n      context.fillStyle = 'red';\n      context.arc(featureX, featureY, 2, 0, 2 * Math.PI);\n      context.stroke();\n      context.closePath();\n\n      var projectionX = turtleMindModel.estimatedTurtlePosition.x + Math.cos(angleInRadians) * turtleState.lidarLength;\n      var projectionY = turtleMindModel.estimatedTurtlePosition.y + Math.sin(angleInRadians) * turtleState.lidarLength\n      var featureFound = false;\n      for (var j = 0; j < turtleMindModel.features.length; j++) {\n        var feature = turtleMindModel.features[j];\n        var detections = inteceptCircleLineSeg(feature.x, feature.y, turtleMindModel.featureDetectionRadius, turtleMindModel.estimatedTurtlePosition.x, turtleMindModel.estimatedTurtlePosition.y, projectionX, projectionY);\n        if (detections.length > 0) {\n          featureFound = true;\n        }\n      }\n      if (!featureFound) {\n        turtleMindModel.features.push({\n          x: turtleMindModel.estimatedTurtlePosition.x + Math.cos(angleInRadians) * distance,\n          y: turtleMindModel.estimatedTurtlePosition.y + Math.sin(angleInRadians) * distance,\n        });\n      }\n\n      context.strokeStyle = 'lightgray';\n      context.fillStyle = 'lightgray';\n      context.beginPath();\n      context.moveTo(turtleState.x, turtleState.y);\n      context.lineTo(featureX, featureY);\n      context.stroke();\n      context.closePath();\n\n      // Mark Feature in Lidar data\n      var maxNumScans = 360 / turtleState.lidarMinResolution;\n      var rotationOffset = maxNumScans / 2;\n\n      var scanProfileX = 200 + ((i + rotationOffset) % maxNumScans);\n      var scanProfileYStart = 90;\n      var scanProfileYEnd = scanProfileYStart - rateOfChanges1st[i];\n\n      context.beginPath();\n      context.strokeStyle = 'red';\n      context.fillStyle = 'red';\n      context.arc(scanProfileX, scanProfileYEnd, 2, 0, 2 * Math.PI);\n      context.stroke();\n      context.closePath();\n\n      // Mark Feature in 1st derivative data\n      var scanProfileX = 200 + ((i + rotationOffset) % maxNumScans);\n      var scanProfileYStart = 50;\n      var scanProfileYEnd = scanProfileYStart - currentFrame[i];\n\n      context.beginPath();\n      context.strokeStyle = 'red';\n      context.fillStyle = 'red';\n      context.arc(scanProfileX, scanProfileYEnd, 2, 0, 2 * Math.PI);\n      context.stroke();\n      context.closePath();\n    }\n  }\n}\n\nvar callback = function() {\n  drawSimulation();\n  window.requestAnimationFrame(callback);\n}\n\nwindow.requestAnimationFrame(callback);\n\nwindow.addEventListener(\"keydown\", function(event) {\n  if (event.key == \"ArrowUp\") {\n\n    var dx = Math.cos(Math.PI / 180 * turtleState.theta) * 3;\n    var dy = Math.sin(Math.PI / 180 * turtleState.theta) * 3;\n\n    turtleState.x += dx;\n    turtleState.y += dy;\n\n    turtleMindModel.moveTurtleBy(dx, dy)\n  }\n  if (event.key == \"ArrowDown\") {\n    var dx = Math.cos(Math.PI / 180 * turtleState.theta) * -3;\n    var dy =  Math.sin(Math.PI / 180 * turtleState.theta) * -3;\n\n    turtleState.x += dx;\n    turtleState.y += dy;\n\n    turtleMindModel.moveTurtleBy(dx, dy)\n  }\n  if (event.key == \"ArrowLeft\") {\n    turtleState.theta -= 2;\n\n    turtleMindModel.rotateTurtle(-2);\n  }\n  if (event.key == \"ArrowRight\") {\n    turtleState.theta += 2;\n\n    turtleMindModel.rotateTurtle(2);\n  }\n});\n\n"]}