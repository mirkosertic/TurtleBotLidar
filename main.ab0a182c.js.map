{"version":3,"sources":["js/geom.js","js/noise.js","js/envsim.js","js/derivative.js","js/main.js"],"names":["Point","x","y","anotherPoint","dx","dy","Math","sqrt","angle","distance","angleInRadians","PI","cos","sin","mx","my","Linesegment","a","b","otherLineSegment","s1_x","s1_y","s2_x","s2_y","s","t","gaussianNoise","value","u","v","random","num","log","TurtleState","location","theta","lidarLength","lidarNoise","lidarMinResolution","walls","positionOverflowingValueFrom","pos","data","maxsize","derivativeOf","offset","result","i","leftPos","rightPos","canvas","document","getElementById","context","getContext","lineWidth","strokeStyle","fillStyle","scale","translate","turtleState","turtleMindModel","particles","score","estimatedState","undefined","length","particle","features","featureDetectionRadius","moveTurtleBy","newParticles","concat","rotateTurtle","updateParticleState","detectedFeatures","feature","push","polarProjection","j","expectedFeature","k","detectedFeature","featureProjection","beginPath","arc","stroke","closePath","dfX","abs","dfY","identified","meanScore","filter","index","arr","console","noiseFilter","smoothing","enabled","currentValue","process","newValue","polarLine","color","rayTarget","moveTo","lineTo","renderData","xp","yp","size","shiftOffset","scaleFactor","caption","height","dataPoint","drawXPosition","drawYPositionStart","drawYPositionEnd","save","rotate","textAlign","font","fillText","restore","drawSimulation","clearRect","wall","currentRay","currentFrame","angles","maxNumScans","rotationOffset","lidarRayTarget","nearestIntersection","intersection","intersectionWith","distanceTo","wallHitPoint","scanProfileX","scanProfileYEnd","rateOfChanges1st","rateOfChanges2nd","current1stValue","previous1stValue","current2ndValue","featureDetected","featureLocation","scanProfileYStart","callback","window","requestAnimationFrame","addEventListener","event","key"],"mappings":"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","file":"main.ab0a182c.js","sourceRoot":"..","sourcesContent":["/**\n * A simple point.\n */\nclass Point {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  distanceTo(anotherPoint) {\n    const dx = anotherPoint.x - this.x;\n    const dy = anotherPoint.y - this.y;\n    return Math.sqrt(dx * dx + dy * dy);\n  }\n\n  polarProjection(angle, distance) {\n    const angleInRadians = Math.PI / 180 * angle;\n    return new Point(this.x + Math.cos(angleInRadians) * distance, this.y + Math.sin(angleInRadians) * distance);\n  }\n\n  translate(mx, my) {\n    this.x += mx;\n    this.y += my;\n  }\n}\n\n/**\n * A line is a connection between two points.\n */\nclass Linesegment {\n  constructor(a, b) {\n    this.a = a;\n    this.b = b;\n  }\n\n  intersectionWith(otherLineSegment) {\n    const s1_x = this.b.x - this.a.x;\n    const s1_y = this.b.y - this.a.y;\n    const s2_x = otherLineSegment.b.x - otherLineSegment.a.x;\n    const s2_y = otherLineSegment.b.y - otherLineSegment.a.y;\n\n    const s = (-s1_y * (this.a.x - otherLineSegment.a.x) + s1_x * (this.a.y - otherLineSegment.a.y)) / (-s2_x * s1_y + s1_x * s2_y);\n    const t = ( s2_x * (this.a.y - otherLineSegment.a.y) - s2_y * (this.a.x - otherLineSegment.a.x)) / (-s2_x * s1_y + s1_x * s2_y);\n\n    if (s >= 0 && s <= 1 && t >= 0 && t <= 1) {\n      return new Point(this.a.x + (t * s1_x), this.a.y + (t * s1_y));\n    }\n\n    return undefined;\n  }\n}\n\nexport {Point, Linesegment};\n","function gaussianNoise(value) {\n  //return (((Math.random() + Math.random() + Math.random() + Math.random()) / 4) - 0.5) * value;\n  let u = 0, v = 0;\n  while(u === 0) u = Math.random(); //Converting [0,1) to (0,1)\n  while(v === 0) v = Math.random();\n  let num = Math.sqrt( -2.0 * Math.log( u ) ) * Math.cos( 2.0 * Math.PI * v );\n  num = num / 10.0 + 0.5; // Translate to 0 -> 1\n  if (num > 1 || num < 0) return gaussianNoise() // resample between 0 and 1\n  return (num - 0.5) * value\n}\n\nexport {gaussianNoise}\n","import {Linesegment, Point} from \"./geom.js\"\n\nclass TurtleState {\n\n  constructor() {\n    this.location = new Point(56, 56);\n    this.theta = 0;\n    this.lidarLength = 100;\n    this.lidarNoise = 0;\n    this.lidarMinResolution = 1;\n    this.walls = [\n      new Linesegment(new Point(0,0), new Point(150, 0)),\n      new Linesegment(new Point(150, 0), new Point(150, 100)),\n      new Linesegment(new Point(150, 100), new Point(0, 100)),\n      new Linesegment(new Point(0, 0), new Point(0, 100)),\n      new Linesegment(new Point(150, 80), new Point(130, 80)),\n      new Linesegment(new Point(130, 100), new Point(130, 80))\n    ];\n  }\n}\n\nexport {TurtleState};\n","function positionOverflowingValueFrom(pos, data, maxsize) {\n  if (pos < 0) {\n    pos += maxsize;\n  } else if (pos >= maxsize) {\n    pos -= maxsize;\n  }\n  return data[pos];\n}\n\nfunction derivativeOf(data,maxsize,offset) {\n  const result = []\n  for (let i = 0; i < maxsize; i++) {\n    const leftPos = positionOverflowingValueFrom(i, data, maxsize);\n    const rightPos = positionOverflowingValueFrom(i + offset, data, maxsize);\n    if (leftPos && rightPos) {\n      result[i] = (rightPos - leftPos);\n    }\n  }\n  return result;\n}\n\nexport {derivativeOf, positionOverflowingValueFrom};\n","import {Point, Linesegment} from \"./geom.js\";\nimport {gaussianNoise} from \"./noise.js\";\nimport {TurtleState} from \"./envsim.js\";\nimport {derivativeOf, positionOverflowingValueFrom} from \"./derivative.js\";\n\nconst canvas = document.getElementById(\"rendering\");\nconst context = canvas.getContext(\"2d\");\n\ncontext.lineWidth = 1;\ncontext.strokeStyle = 'black';\ncontext.fillStyle = 'black';\ncontext.scale(2, 2);\ncontext.translate(100, 100);\n\nconst turtleState = new TurtleState();\n\nconst turtleMindModel = {\n  particles: [\n    {\n      location: new Point(0, 0),\n      theta: 0,\n      score: 1\n    }\n  ],\n  estimatedState: function () {\n    var x = undefined;\n    var y = undefined;\n    var theta = undefined;\n    for (let i = 0; i < this.particles.length; i++) {\n      const particle = this.particles[i];\n      if (x) {\n        x = (x + particle.location.x) / 2;\n      } else {\n        x = particle.location.x;\n      }\n      if (y) {\n        y = (y + particle.location.y) / 2;\n      } else {\n        y = particle.location.y;\n      }\n      if (theta) {\n        theta = (theta + particle.theta) / 2;\n      } else {\n        theta = particle.theta;\n      }\n    }\n    return {\n      location: new Point(x, y),\n      theta: theta\n    }\n  },\n  features: [],\n  featureDetectionRadius: 3,\n\n  moveTurtleBy: function (dx, dy) {\n    const newParticles = [];\n    for (let i = 0; i < this.particles.length; i++) {\n      const particle = this.particles[i];\n      particle.location.translate(dx, dy);\n    }\n    this.particles = this.particles.concat(newParticles);\n  },\n\n  rotateTurtle: function (angle) {\n    const newParticles = [];\n    for (let i = 0; i < this.particles.length; i++) {\n      const particle = this.particles[i];\n      particle.theta += angle;\n    }\n    this.particles = this.particles.concat(newParticles);\n  },\n  updateParticleState: function (detectedFeatures) {\n    const estimatedState = turtleMindModel.estimatedState();\n\n    // If we do not have features, we initially add the found one to our map\n    if (this.features.length === 0) {\n      for (let i = 0; i < detectedFeatures.length; i++) {\n        const feature = detectedFeatures[i];\n        this.features.push(\n          estimatedState.location.polarProjection(feature.angle + estimatedState.theta, feature.distance)\n        );\n      }\n    } else {\n      // Now comes the tricky part: we evaluate the found features against\n      // every particle and verify the expectations\n      for (let i = 0; i < this.particles.length; i++) {\n        const particle = this.particles[i];\n        particle.score = 0;\n        for (let j = 0; j < this.features.length; j++) {\n          const expectedFeature = this.features[j];\n          const dx = expectedFeature.x - particle.location.x;\n          const dy = expectedFeature.y - particle.location.y;\n          // Now we check, if there is such a feature\n          for (let k = 0; k < detectedFeatures.length; k++) {\n            const detectedFeature = detectedFeatures[k];\n\n            const featureProjection = new Point(0, 0).polarProjection(detectedFeature.angle + particle.theta, detectedFeature.distance);\n\n            context.beginPath();\n            context.strokeStyle = 'gray';\n            context.fillStyle = 'gray';\n            context.arc(56 + particle.location.x + featureProjection.x, particle.location.y + 200 + featureProjection.y, 8, 0, 2 * Math.PI);\n            context.stroke();\n            context.closePath();\n\n            context.beginPath();\n            context.strokeStyle = 'blue';\n            context.fillStyle = 'blue';\n            context.arc(56 + estimatedState.location.x + dx, 200 + estimatedState.location.y + dy, 6, 0, 2 * Math.PI);\n            context.stroke();\n            context.closePath();\n\n            const dfX = Math.abs(featureProjection.x - dx);\n            const dfY = Math.abs(featureProjection.y - dy);\n\n            if (dfX < 10 && dfY < 10) {\n              detectedFeature.identified = true;\n              // Maybe a match, the particle gets a hit point\n              // TODO: We know the particle, we can adjust the particle position, maybe with a Kalman filter?\n              particle.score += 1;\n            }\n          }\n        }\n      }\n      // We calculate the mean score\n      var meanScore = undefined;\n      for (let i = 0; i < this.particles.length; i++) {\n        if (meanScore) {\n          meanScore = (meanScore + this.particles[i].score) / 2;\n        } else {\n          meanScore = this.particles[i].score;\n        }\n      }\n\n      // We are done here, now we evaluate dead particles\n      this.particles = this.particles.filter(function (value, index, arr) {\n        if (value.score >= meanScore) {\n          return true;\n        } else {\n          console.log(\"Particle \" + index + \" got score \" + value.score + \" from \" + detectedFeatures.length + \" and will be removed!\");\n          return false;\n        }\n      });\n    }\n  }\n};\n\nconst noiseFilter = {\n  smoothing : 2.5,\n  enabled: false,\n  currentValue: [],\n\n  process: function(pos, newValue) {\n    if (this.enabled) {\n      if (this.currentValue[pos]) {\n        this.currentValue[pos] += (newValue - this.currentValue[pos]) / this.smoothing;\n        return this.currentValue[pos];\n      } else {\n        this.currentValue[pos] = newValue;\n        return newValue;\n      }\n    } else {\n      return newValue;\n    }\n  }\n}\n\nfunction polarLine(location, angle, length, color) {\n  const rayTarget = location.polarProjection(angle, length);\n  context.strokeStyle = color;\n  context.fillStyle = color;\n  context.beginPath();\n  context.moveTo(location.x, location.y);\n  context.lineTo(rayTarget.x, rayTarget.y);\n  context.stroke();\n  context.closePath();\n}\n\nfunction renderData(xp, yp, color, data, size, shiftOffset, scaleFactor, caption, height) {\n\n  for (let i = 0; i < size; i++) {\n\n    const dataPoint = data[i];\n    if (dataPoint) {\n\n      const drawXPosition = xp + ((i + shiftOffset) % size);\n      const drawYPositionStart = yp;\n      const drawYPositionEnd = drawYPositionStart + dataPoint * scaleFactor;\n\n      context.beginPath();\n      context.strokeStyle = color;\n      context.fillStyle = color;\n\n      context.moveTo(drawXPosition, drawYPositionStart);\n      context.lineTo(drawXPosition, drawYPositionEnd);\n\n      context.stroke();\n      context.closePath();\n    }\n  }\n\n  context.save();\n\n  context.beginPath();\n  context.strokeStyle = 'black';\n  context.fillStyle = 'black';\n\n  context.moveTo(xp, yp - height);\n  context.lineTo(xp, yp + height);\n\n  context.translate(xp, yp);\n  context.rotate(-Math.PI / 2);\n  context.textAlign = 'center';\n  context.font = \"8px Arial\";\n  context.fillText(caption, 0, -5);\n\n  context.stroke();\n  context.closePath();\n\n  context.restore();\n}\n\nfunction drawSimulation() {\n\n  context.clearRect(-100, -100, 1000, 1000);\n\n  // Render reality\n  context.strokeStyle = 'black';\n  context.fillStyle = 'black';\n  context.textAlign = 'left';\n  context.font = \"8px Arial\";\n  context.fillText('Reality', -20, -20);\n\n  // Draw the walls\n  context.strokeStyle = 'black';\n  context.fillStyle = 'black';\n  context.beginPath();\n  for (let i = 0; i < turtleState.walls.length; i++) {\n    const wall = turtleState.walls[i];\n    context.moveTo(wall.a.x, wall.a.y);\n    context.lineTo(wall.b.x, wall.b.y);\n  }\n  context.stroke();\n  context.closePath();\n\n  // Draw the turtle\n  context.beginPath();\n  context.strokeStyle = 'gray';\n  context.fillStyle = 'gray';\n  context.arc(turtleState.location.x, turtleState.location.y, 8, 0, 2 * Math.PI);\n  context.stroke();\n  context.closePath();\n\n  polarLine(turtleState.location, turtleState.theta, 20, 'green');\n\n  // Render turtles model\n  context.strokeStyle = 'black';\n  context.fillStyle = 'black';\n  context.textAlign = 'left';\n  context.font = \"8px Arial\";\n  context.fillText('Turtles model no.F. = ' + turtleMindModel.features.length + \", no. P = \" + turtleMindModel.particles.length, -20, 120);\n\n  for (let i = 0; i < turtleMindModel.particles.length; i++) {\n    const particle = turtleMindModel.particles[i];\n    context.beginPath();\n    context.strokeStyle = 'gray';\n    context.fillStyle = 'gray';\n    context.arc(particle.x + 56, particle.y + 200, 8, 0, 2 * Math.PI);\n    context.stroke();\n    context.closePath();\n    polarLine(new Point(particle.x + 56, particle.y + 200), particle.theta, 20, 'green');\n  }\n\n  for (let i = 0; i < turtleMindModel.features.length; i++) {\n    const feature = turtleMindModel.features[i];\n    context.beginPath();\n    context.strokeStyle = 'red';\n    context.fillStyle = 'red';\n    context.arc(feature.x - 1 + 56, feature.y -1 + 200, 3, 0, 2 * Math.PI);\n    context.stroke();\n    context.closePath();\n  }\n\n  var currentRay = 0;\n  const currentFrame = [];\n  const angles = [];\n\n  const maxNumScans = 360 / turtleState.lidarMinResolution;\n  const rotationOffset = maxNumScans / 2;\n\n  for (let i = turtleState.theta; i < turtleState.theta + 360; i += turtleState.lidarMinResolution, currentRay++) {\n\n    const lidarRayTarget = turtleState.location.polarProjection(i, turtleState.lidarLength);\n\n    var nearestIntersection = undefined;\n    for (let j = 0; j < turtleState.walls.length; j++) {\n      const wall = turtleState.walls[j];\n      const intersection = wall.intersectionWith(new Linesegment(turtleState.location, lidarRayTarget));\n      if (intersection) {\n        const distance = noiseFilter.process(currentRay, turtleState.location.distanceTo(intersection) + gaussianNoise(turtleState.lidarNoise));\n        if (nearestIntersection) {\n          if (nearestIntersection.distance > distance) {\n            nearestIntersection = {\n              distance: distance,\n              intersection: intersection\n            };\n          }\n        } else {\n          nearestIntersection = {\n            distance: distance,\n            intersection: intersection\n          }\n        }\n      }\n    }\n\n    if (nearestIntersection) {\n\n      currentFrame[currentRay] = nearestIntersection.distance;\n      angles[currentRay] = i;\n\n      // Do some back projection\n      const wallHitPoint = turtleState.location.polarProjection(i, nearestIntersection.distance);\n\n      context.beginPath();\n      context.strokeStyle = 'CadetBlue';\n      context.fillStyle = 'CadetBlue';\n      context.arc(wallHitPoint.x, wallHitPoint.y, 2, 0, 2 * Math.PI);\n      context.stroke();\n      context.closePath();\n\n      context.beginPath();\n      if (currentRay === 0) {\n        context.strokeStyle = 'green';\n        context.fillStyle = 'green';\n      } else {\n        context.strokeStyle = 'CadetBlue';\n        context.fillStyle = 'CadetBlue';\n      }\n\n      const scanProfileX = 200 + ((currentRay + rotationOffset) % maxNumScans);\n      const scanProfileYStart = 50;\n      const scanProfileYEnd = scanProfileYStart - nearestIntersection.distance;\n\n      context.moveTo(scanProfileX, scanProfileYStart);\n      context.lineTo(scanProfileX, scanProfileYEnd);\n\n      context.stroke();\n      context.closePath();\n\n    } else {\n      context.strokeStyle = 'rgba(128,128,128,0.05)';\n      context.fillStyle = 'rgba(128,128,128,0.05)';\n      context.beginPath();\n      context.moveTo(turtleState.location.x, turtleState.location.y);\n      context.lineTo(lidarRayTarget.x, lidarRayTarget.y);\n      context.stroke();\n      context.closePath();\n    }\n  }\n\n  context.save();\n  context.beginPath();\n  context.strokeStyle = 'black';\n  context.fillStyle = 'black';\n  context.moveTo(200, 50);\n  context.lineTo(200, 50 - 120);\n  context.translate(200, 50);\n  context.rotate(-Math.PI / 2);\n  context.textAlign = 'center';\n  context.font = \"8px Arial\";\n  context.fillText('Lidar distance', 60, -5);\n  context.stroke();\n  context.closePath();\n  context.restore();\n\n  const rateOfChanges1st = derivativeOf(currentFrame, currentRay, 1);\n  const rateOfChanges2nd = derivativeOf(rateOfChanges1st, currentRay, 1);\n\n  // Render derivatives\n  renderData(200, 90, 'DarkSlateGrey', rateOfChanges1st, maxNumScans, rotationOffset, 3, '1st derivative', 20);\n  renderData(200, 160, 'DarkSlateGrey', rateOfChanges2nd, maxNumScans, rotationOffset, 15, '2nd derivative',20);\n\n  const detectedFeatures = [];\n\n  // Check for maxima and sharp edges\n  for (let i = 0; i < currentRay; i++) {\n    const current1stValue = positionOverflowingValueFrom(i, rateOfChanges1st, maxNumScans);\n    const previous1stValue = positionOverflowingValueFrom(i - 1, rateOfChanges1st, maxNumScans);\n\n    const current2ndValue = positionOverflowingValueFrom(i, rateOfChanges2nd, maxNumScans);\n\n    var featureDetected = false;\n    if (current1stValue && previous1stValue && current2ndValue) {\n      if (previous1stValue >= 0 && current1stValue < 0) {\n        // Farest point, maxima in lidar data\n        featureDetected = true;\n      } else if (previous1stValue < 0 && current1stValue > 0.025) {\n        // Sharp edge\n        featureDetected = true;\n      }\n    }\n    const distance = currentFrame[i];\n    if (featureDetected && distance) {\n\n      const angle = angles[i];\n      const featureLocation = turtleState.location.polarProjection(angle, distance);\n\n      detectedFeatures.push({\n        angle: angle - turtleState.theta,\n        distance: distance\n      });\n\n      // Mark Feature on the Map\n      context.beginPath();\n      context.strokeStyle = 'red';\n      context.fillStyle = 'red';\n      context.arc(featureLocation.x, featureLocation.y, 2, 0, 2 * Math.PI);\n      context.stroke();\n      context.closePath();\n\n      context.strokeStyle = 'lightgray';\n      context.fillStyle = 'lightgray';\n      context.beginPath();\n      context.moveTo(turtleState.location.x, turtleState.location.y);\n      context.lineTo(featureLocation.x, featureLocation.y);\n      context.stroke();\n      context.closePath();\n\n      // Mark Feature in Lidar data\n      let scanProfileX = 200 + ((i + rotationOffset) % maxNumScans);\n      let scanProfileYStart = 90;\n      let scanProfileYEnd = scanProfileYStart - rateOfChanges1st[i];\n\n      context.beginPath();\n      context.strokeStyle = 'red';\n      context.fillStyle = 'red';\n      context.arc(scanProfileX, scanProfileYEnd, 2, 0, 2 * Math.PI);\n      context.stroke();\n      context.closePath();\n\n      // Mark Feature in 1st derivative data\n      scanProfileX = 200 + ((i + rotationOffset) % maxNumScans);\n      scanProfileYStart = 50;\n      scanProfileYEnd = scanProfileYStart - currentFrame[i];\n\n      context.beginPath();\n      context.strokeStyle = 'red';\n      context.fillStyle = 'red';\n      context.arc(scanProfileX, scanProfileYEnd, 2, 0, 2 * Math.PI);\n      context.stroke();\n      context.closePath();\n    }\n  }\n\n  turtleMindModel.updateParticleState(detectedFeatures);\n}\n\nfunction callback() {\n  drawSimulation();\n  window.requestAnimationFrame(callback);\n}\n\nwindow.requestAnimationFrame(callback);\n\nwindow.addEventListener(\"keydown\", function(event) {\n  if (event.key === \"ArrowUp\") {\n\n    const dx = Math.cos(Math.PI / 180 * turtleState.theta) * 3;\n    const dy = Math.sin(Math.PI / 180 * turtleState.theta) * 3;\n\n    turtleState.location.translate(dx, dy);\n\n    turtleMindModel.moveTurtleBy(dx, dy)\n  }\n  if (event.key === \"ArrowDown\") {\n    const dx = Math.cos(Math.PI / 180 * turtleState.theta) * -3;\n    const dy =  Math.sin(Math.PI / 180 * turtleState.theta) * -3;\n\n    turtleState.location.translate(dx, dy);\n\n    turtleMindModel.moveTurtleBy(dx, dy)\n  }\n  if (event.key === \"ArrowLeft\") {\n    turtleState.theta -= 2;\n\n    turtleMindModel.rotateTurtle(-2);\n  }\n  if (event.key === \"ArrowRight\") {\n    turtleState.theta += 2;\n\n    turtleMindModel.rotateTurtle(2);\n  }\n});\n\n"]}