{"version":3,"sources":["js/main.js"],"names":["get_distance","x1","y1","x2","y2","noise","dx","dy","Math","sqrt","get_line_intersection","p0_x","p0_y","p1_x","p1_y","p2_x","p2_y","p3_x","p3_y","s1_x","s1_y","s2_x","s2_y","s","t","x","y","inteceptCircleLineSeg","cx","cy","cr","p1x","p1y","p2x","p2y","a","b","c","d","u1","u2","ret","retP1","retP2","v1","v2","isNaN","length","canvas","document","getElementById","context","getContext","walls","lineWidth","strokeStyle","fillStyle","scale","translate","turtleState","theta","lidarLength","lidarNoise","lidarMinResolution","turtleMindModel","particles","score","estimatedState","undefined","i","particle","randomness","features","featureDetectionRadius","moveTurtleBy","newParticles","j","newParticle","gaussianNoise","push","concat","rotateTurtle","angle","updateParticleState","detectedFeatures","feature","angleInRadians","PI","featureX","cos","distance","featureY","sin","expectedFeature","k","detectedFeature","detectedFeatureX","detectedFeatureY","beginPath","arc","stroke","closePath","dfX","abs","dfY","console","log","meanScore","filter","value","index","arr","noiseFilter","smoothing","enabled","currentValue","process","pos","newValue","u","v","random","num","positionOverflowingValueFrom","data","maxsize","derivativeOf","offset","result","leftPos","rightPos","polarLine","xp","yp","color","xTarget","yTarget","moveTo","lineTo","renderData","size","shiftOffset","scaleFactor","caption","height","dataPoint","drawXPosition","drawYPositionStart","drawYPositionEnd","save","rotate","textAlign","font","fillText","restore","drawSimulation","clearRect","wall","currentRay","currentFrame","angles","rotationOffset","maxNumScans","rayTargetX","rayTargetY","nearestIntersection","intersection","wallX","wallY","scanProfileX","scanProfileYEnd","scanProfileYStart","rateOfChanges1st","rateOfChanges2nd","current1stValue","previous1stValue","current2ndValue","featureDetected","callback","window","requestAnimationFrame","addEventListener","event","key"],"mappings":"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","file":"main.8f63fb8f.js","sourceRoot":"..","sourcesContent":["function get_distance(x1, y1, x2, y2, noise) {\n  var dx = x2 - x1;\n  var dy = y2 - y1;\n  return Math.sqrt(dx *  dx + dy * dy) + noise;\n}\n\nfunction get_line_intersection(p0_x, p0_y, p1_x, p1_y, p2_x, p2_y, p3_x, p3_y)\n{\n  var s1_x, s1_y, s2_x, s2_y;\n  s1_x = p1_x - p0_x;\n  s1_y = p1_y - p0_y;\n  s2_x = p3_x - p2_x;\n  s2_y = p3_y - p2_y;\n\n  var s, t;\n  s = (-s1_y * (p0_x - p2_x) + s1_x * (p0_y - p2_y)) / (-s2_x * s1_y + s1_x * s2_y);\n  t = ( s2_x * (p0_y - p2_y) - s2_y * (p0_x - p2_x)) / (-s2_x * s1_y + s1_x * s2_y);\n\n  if (s >= 0 && s <= 1 && t >= 0 && t <= 1)\n  {\n    return {\n      x: p0_x + (t * s1_x),\n      y: p0_y + (t * s1_y)\n    }\n  }\n\n  return undefined;\n}\n\n// Taken from https://stackoverflow.com/questions/37224912/circle-line-segment-collision/37225895\nfunction inteceptCircleLineSeg(cx, cy, cr, p1x, p1y, p2x, p2y) {\n  var a, b, c, d, u1, u2, ret, retP1, retP2, v1, v2;\n  v1 = {};\n  v2 = {};\n  v1.x = p2x - p1x;\n  v1.y = p2y - p1y;\n  v2.x = p1x - cx;\n  v2.y = p1y - cy;\n  b = (v1.x * v2.x + v1.y * v2.y);\n  c = 2 * (v1.x * v1.x + v1.y * v1.y);\n  b *= -2;\n  d = Math.sqrt(b * b - 2 * c * (v2.x * v2.x + v2.y * v2.y - cr * cr));\n  if (isNaN(d)){ // no intercept\n    return [];\n  }\n  u1 = (b - d) / c;  // these represent the unit distance of point one and two on the line\n  u2 = (b + d) / c;\n  retP1 = {};   // return points\n  retP2 = {}\n  ret = []; // return array\n  if(u1 <= 1 && u1 >= 0){  // add point if on the line segment\n    retP1.x = p1x + v1.x * u1;\n    retP1.y = p2y + v1.y * u1;\n    ret[0] = retP1;\n  }\n  if(u2 <= 1 && u2 >= 0){  // second add point if on the line segment\n    retP2.x = p1x + v1.x * u2;\n    retP2.y = p2y + v1.y * u2;\n    ret[ret.length] = retP2;\n  }\n  return ret;\n}\n\nvar canvas = document.getElementById(\"rendering\");\nvar context = canvas.getContext(\"2d\");\n\nvar walls = [\n  {\n    x1: 0,\n    y1: 0,\n    x2: 150,\n    y2 : 0\n  },\n  {\n    x1: 150,\n    y1: 0,\n    x2: 150,\n    y2 : 100\n  },\n  {\n    x1: 150,\n    y1: 100,\n    x2: 0,\n    y2 : 100\n  },\n  {\n    x1: 0,\n    y1: 0,\n    x2: 0,\n    y2 : 100\n  },\n  {\n    x1: 150,\n    y1: 80,\n    x2: 130,\n    y2 : 80\n  },\n  {\n    x1: 130,\n    y1: 100,\n    x2: 130,\n    y2 : 80\n  },\n];\n\ncontext.lineWidth = 1;\ncontext.strokeStyle = 'black';\ncontext.fillStyle = 'black';\ncontext.scale(2, 2);\ncontext.translate(100, 100);\n\nvar turtleState = {\n  x: 56,\n  y: 56,\n  theta: 0,\n  lidarLength: 100,\n  lidarNoise: 0,\n  lidarMinResolution: 1,\n}\n\nvar turtleMindModel = {\n  particles: [\n    {\n      x: 0,\n      y:0,\n      theta: 0,\n      score: 1\n    }\n  ],\n  estimatedState: function() {\n      var x = undefined;\n      var y = undefined;\n      var theta = undefined;\n      for (var i = 0; i < this.particles.length; i++) {\n        var particle = this.particles[i];\n        if (x) {\n          x = (x + particle.x) / 2;\n        } else {\n          x = particle.x;\n        }\n        if (y) {\n          y = (y + particle.y) / 2;\n        } else {\n          y = particle.y;\n        }\n        if (theta) {\n          theta = (theta + particle.theta) / 2;\n        } else {\n          theta = particle.theta;\n        }\n      }\n      return {\n        x: x,\n        y: y,\n        theta: theta\n      }\n  },\n  randomness: 1,\n  features: [],\n  featureDetectionRadius: 3,\n  moveTurtleBy: function(dx, dy) {\n    var newParticles = [];\n    for (var i = 0; i < this.particles.length; i++) {\n      var particle = this.particles[i];\n      particle.x += dx;\n      particle.y += dy;\n      if (particle.score > 0) {\n        for (var j = 0; j < this.randomness; j++) {\n          var newParticle = {\n            x: particle.x + dx + gaussianNoise(30),\n            y: particle.y + dy + gaussianNoise(30),\n            theta: particle.theta + gaussianNoise(10),\n          };\n          newParticles.push(newParticle);\n        }\n      }\n    }\n    this.particles = this.particles.concat(newParticles);\n  },\n  rotateTurtle: function(angle) {\n    var newParticles = [];\n    for (var i = 0; i < this.particles.length; i++) {\n      var particle = this.particles[i];\n      particle.theta += angle;\n      if (particle.score > 0) {\n        for (var j = 0; j < this.randomness; j++) {\n          var newParticle = {\n            x: particle.x + gaussianNoise(5),\n            y: particle.y + gaussianNoise(5),\n            theta: particle.theta + angle + gaussianNoise(10),\n          };\n          newParticles.push(newParticle);\n        }\n      }\n    }\n    this.particles = this.particles.concat(newParticles);\n  },\n  updateParticleState: function(detectedFeatures) {\n    var estimatedState = turtleMindModel.estimatedState();\n\n    // If we do not have features, we initially add the found one to our map\n    if (this.features.length === 0) {\n      for (var i = 0; i < detectedFeatures.length; i++) {\n        var feature = detectedFeatures[i];\n\n        var angleInRadians = Math.PI / 180 * (feature.angle + estimatedState.theta);\n        var featureX = estimatedState.x + Math.cos(angleInRadians) * feature.distance;\n        var featureY = estimatedState.y + Math.sin(angleInRadians) * feature.distance;\n\n        this.features.push({\n            x: featureX,\n            y: featureY\n        });\n      }\n    } else {\n      // Now comes the tricky part: we evaluate the found features against\n      // every particle and verify the expectations\n      for (var i = 0; i < this.particles.length; i++) {\n        var particle = this.particles[i];\n        particle.score = 0;\n        for (var j = 0; j < this.features.length; j++) {\n          var expectedFeature = this.features[j];\n          var dx = expectedFeature.x - particle.x;\n          var dy = expectedFeature.y - particle.y;\n          // Now we check, if there is such a feature\n          for (var k = 0; k < detectedFeatures.length; k++) {\n            var detectedFeature = detectedFeatures[k];\n\n            var angleInRadians = Math.PI / 180 * (detectedFeature.angle + particle.theta);\n            var detectedFeatureX = Math.cos(angleInRadians) * detectedFeature.distance;\n            var detectedFeatureY = Math.sin(angleInRadians) * detectedFeature.distance;\n\n            context.beginPath();\n            context.strokeStyle = 'gray';\n            context.fillStyle = 'gray';\n            context.arc(56 + particle.x + detectedFeatureX, particle.y + 200 + detectedFeatureY, 8, 0, 2 * Math.PI);\n            context.stroke();\n            context.closePath();\n\n            context.beginPath();\n            context.strokeStyle = 'blue';\n            context.fillStyle = 'blue';\n            context.arc(56 + estimatedState.x + dx, 200 + estimatedState.y + dy, 6, 0, 2 * Math.PI);\n            context.stroke();\n            context.closePath();\n\n            var dfX = Math.abs(detectedFeatureX - dx);\n            var dfY = Math.abs(detectedFeatureY - dy);\n\n            console.log(\"dfX = \" + dfX + \", dfY = \" + dfY);\n\n            if (dfX < 1 && dfY < 1) {\n              // Maybe a match, the particle gets a hit point\n              particle.score += 1;\n            }\n          }\n        }\n      }\n      // We calculate the mean score\n      var meanScore = undefined;\n      for (var i = 0; i < this.particles.length; i++) {\n        if (meanScore) {\n          meanScore = (meanScore + this.particles[i].score) / 2;\n        } else {\n          meanScore = this.particles[i].score;\n        }\n      }\n\n      // We are done here, now we evaluate dead particles\n      this.particles = this.particles.filter(function(value, index, arr) {\n        if (value.score >= meanScore) {\n          return true;\n        } else {\n          console.log(\"Particle \" + index + \" got score \" + value.score + \" from \" + detectedFeatures.length + \" and will be removed!\");\n          return false;\n        }\n      });\n    }\n  }\n};\n\nvar noiseFilter = {\n  smoothing : 2.5,\n  enabled: false,\n  currentValue: [],\n  process: function(pos, newValue) {\n    if (this.enabled) {\n      if (this.currentValue[pos]) {\n        this.currentValue[pos] += (newValue - this.currentValue[pos]) / this.smoothing;\n        return this.currentValue[pos];\n      } else {\n        this.currentValue[pos] = newValue;\n        return newValue;\n      }\n    } else {\n      return newValue;\n    }\n  }\n}\n\nfunction gaussianNoise(value) {\n  //return (((Math.random() + Math.random() + Math.random() + Math.random()) / 4) - 0.5) * value;\n  let u = 0, v = 0;\n  while(u === 0) u = Math.random(); //Converting [0,1) to (0,1)\n  while(v === 0) v = Math.random();\n  let num = Math.sqrt( -2.0 * Math.log( u ) ) * Math.cos( 2.0 * Math.PI * v );\n  num = num / 10.0 + 0.5; // Translate to 0 -> 1\n  if (num > 1 || num < 0) return gaussianNoise() // resample between 0 and 1\n  return (num - 0.5) * value\n}\n\nfunction positionOverflowingValueFrom(pos, data, maxsize) {\n  if (pos < 0) {\n    pos += maxsize;\n  } else if (pos >= maxsize) {\n    pos -= maxsize;\n  }\n  return data[pos];\n}\n\nvar derivativeOf = function(data,maxsize,offset) {\n  var result = []\n  for (var i = 0; i < maxsize; i++) {\n    var leftPos = positionOverflowingValueFrom(i, data, maxsize);\n    var rightPos = positionOverflowingValueFrom(i + offset, data, maxsize);\n    if (leftPos && rightPos) {\n      result[i] = (rightPos - leftPos);\n    }\n  }\n  return result;\n}\n\nvar polarLine = function(xp, yp, angle, length, color) {\n  var xTarget = xp + Math.cos(Math.PI / 180 * angle) * length;\n  var yTarget = yp + Math.sin(Math.PI / 180 * angle) * length;\n  context.strokeStyle = color;\n  context.fillStyle = color;\n  context.beginPath();\n  context.moveTo(xp, yp);\n  context.lineTo(xTarget, yTarget);\n  context.stroke();\n  context.closePath();\n}\n\nvar renderData = function(xp, yp, color, data, size, shiftOffset, scaleFactor, caption, height) {\n\n  for (var i = 0; i < size; i++) {\n\n    var dataPoint = data[i];\n    if (dataPoint) {\n\n      var drawXPosition = xp + ((i + shiftOffset) % size);\n      var drawYPositionStart = yp;\n      var drawYPositionEnd = drawYPositionStart + dataPoint * scaleFactor;\n\n      context.beginPath();\n      context.strokeStyle = color;\n      context.fillStyle = color;\n\n      context.moveTo(drawXPosition, drawYPositionStart);\n      context.lineTo(drawXPosition, drawYPositionEnd);\n\n      context.stroke();\n      context.closePath();\n    }\n  }\n\n  context.save();\n\n  context.beginPath();\n  context.strokeStyle = 'black';\n  context.fillStyle = 'black';\n\n  context.moveTo(xp, yp - height);\n  context.lineTo(xp, yp + height);\n\n  context.translate(xp, yp);\n  context.rotate(-Math.PI / 2);\n  context.textAlign = 'center';\n  context.font = \"8px Arial\";\n  context.fillText(caption, 0, -5);\n\n  context.stroke();\n  context.closePath();\n\n  context.restore();\n}\n\nvar drawSimulation = function() {\n\n  context.clearRect(-100, -100, 1000, 1000);\n\n  // Render reality\n  context.strokeStyle = 'black';\n  context.fillStyle = 'black';\n  context.textAlign = 'left';\n  context.font = \"8px Arial\";\n  context.fillText('Reality', -20, -20);\n\n  // Draw the walls\n  context.strokeStyle = 'black';\n  context.fillStyle = 'black';\n  context.beginPath();\n  for (var i = 0; i < walls.length; i++) {\n    var wall = walls[i];\n    context.moveTo(wall.x1, wall.y1);\n    context.lineTo(wall.x2, wall.y2);\n  }\n  context.stroke();\n  context.closePath();\n\n  // Draw the turtle\n  context.beginPath();\n  context.strokeStyle = 'gray';\n  context.fillStyle = 'gray';\n  context.arc(turtleState.x, turtleState.y, 8, 0, 2 * Math.PI);\n  context.stroke();\n  context.closePath();\n\n  polarLine(turtleState.x, turtleState.y, turtleState.theta, 20, 'green');\n\n  // Render turtles model\n  context.strokeStyle = 'black';\n  context.fillStyle = 'black';\n  context.textAlign = 'left';\n  context.font = \"8px Arial\";\n  context.fillText('Turtles model no.F. = ' + turtleMindModel.features.length + \", no. P = \" + turtleMindModel.particles.length, -20, 120);\n\n  for (var i = 0; i < turtleMindModel.particles.length; i++) {\n    var particle = turtleMindModel.particles[i];\n    context.beginPath();\n    context.strokeStyle = 'gray';\n    context.fillStyle = 'gray';\n    context.arc(particle.x + 56, particle.y + 200, 8, 0, 2 * Math.PI);\n    context.stroke();\n    context.closePath();\n    polarLine(particle.x + 56, particle.y + 200, particle.theta, 20, 'green');\n  }\n\n  for (var i = 0; i < turtleMindModel.features.length; i++) {\n    var feature = turtleMindModel.features[i];\n    context.beginPath();\n    context.strokeStyle = 'red';\n    context.fillStyle = 'red';\n    context.arc(feature.x - 1 + 56, feature.y -1 + 200, 3, 0, 2 * Math.PI);\n    context.stroke();\n    context.closePath();\n\n  }\n\n  var currentRay = 0;\n  var currentFrame = [];\n  var angles = [];\n\n  var maxNumScans = 360 / turtleState.lidarMinResolution;\n  var rotationOffset = maxNumScans / 2;\n\n  for (var i = turtleState.theta; i < turtleState.theta + 360; i += turtleState.lidarMinResolution, currentRay++) {\n    var rayTargetX = turtleState.x + Math.cos(Math.PI / 180 * i) * turtleState.lidarLength;\n    var rayTargetY = turtleState.y + Math.sin(Math.PI / 180 * i) * turtleState.lidarLength;\n\n    var nearestIntersection = undefined;\n    for (var j = 0; j < walls.length; j++) {\n      var wall = walls[j];\n\n      var intersection = get_line_intersection(turtleState.x, turtleState.y, rayTargetX, rayTargetY, wall.x1, wall.y1, wall.x2, wall.y2);\n      if (intersection) {\n        var distance = noiseFilter.process(currentRay, get_distance(turtleState.x, turtleState.y, intersection.x, intersection.y, gaussianNoise(turtleState.lidarNoise)));\n        if (nearestIntersection) {\n          if (nearestIntersection.distance > distance) {\n            nearestIntersection = {\n              distance: distance,\n              intersection: intersection\n            };\n          }\n        } else {\n          nearestIntersection = {\n            distance: distance,\n            intersection: intersection\n          }\n        }\n      }\n    }\n\n    if (nearestIntersection) {\n\n      currentFrame[currentRay] = nearestIntersection.distance;\n      angles[currentRay] = i;\n\n      // Do some back projection\n      var angleInRadians = Math.PI / 180 * i;\n      var wallX = turtleState.x + Math.cos(angleInRadians) * nearestIntersection.distance;\n      var wallY = turtleState.y + Math.sin(angleInRadians) * nearestIntersection.distance;\n\n      context.beginPath();\n      context.strokeStyle = 'CadetBlue';\n      context.fillStyle = 'CadetBlue';\n      context.arc(wallX, wallY, 2, 0, 2 * Math.PI);\n      context.stroke();\n      context.closePath();\n\n      context.beginPath();\n      if (currentRay === 0) {\n        context.strokeStyle = 'green';\n        context.fillStyle = 'green';\n      } else {\n        context.strokeStyle = 'CadetBlue';\n        context.fillStyle = 'CadetBlue';\n      }\n\n      var scanProfileX = 200 + ((currentRay + rotationOffset) % maxNumScans);\n      var scanProfileYStart = 50;\n      var scanProfileYEnd = scanProfileYStart - nearestIntersection.distance;\n\n      context.moveTo(scanProfileX, scanProfileYStart);\n      context.lineTo(scanProfileX, scanProfileYEnd);\n\n      context.stroke();\n      context.closePath();\n\n    } else {\n      context.strokeStyle = 'rgba(128,128,128,0.05)';\n      context.fillStyle = 'rgba(128,128,128,0.05)';\n      context.beginPath();\n      context.moveTo(turtleState.x, turtleState.y);\n      context.lineTo(rayTargetX, rayTargetY);\n      context.stroke();\n      context.closePath();\n    }\n  }\n\n  context.save();\n  context.beginPath();\n  context.strokeStyle = 'black';\n  context.fillStyle = 'black';\n  context.moveTo(200, 50);\n  context.lineTo(200, 50 - 120);\n  context.translate(200, 50);\n  context.rotate(-Math.PI / 2);\n  context.textAlign = 'center';\n  context.font = \"8px Arial\";\n  context.fillText('Lidar distance', 60, -5);\n  context.stroke();\n  context.closePath();\n  context.restore();\n\n  var rateOfChanges1st = derivativeOf(currentFrame, currentRay, 1);\n  var rateOfChanges2nd = derivativeOf(rateOfChanges1st, currentRay, 1);\n\n  var maxNumScans = 360 / turtleState.lidarMinResolution;\n  var rotationOffset = maxNumScans / 2;\n\n  // Render derivatives\n  renderData(200, 90, 'DarkSlateGrey', rateOfChanges1st, maxNumScans, rotationOffset, 3, '1st derivative', 20);\n  renderData(200, 160, 'DarkSlateGrey', rateOfChanges2nd, maxNumScans, rotationOffset, 15, '2nd derivative',20);\n\n  var detectedFeatures = [];\n\n  // Check for maxima and sharp edges\n  for (var i = 0; i < currentRay; i++) {\n    var current1stValue = positionOverflowingValueFrom(i, rateOfChanges1st, maxNumScans);\n    var previous1stValue = positionOverflowingValueFrom(i - 1, rateOfChanges1st, maxNumScans);\n\n    var current2ndValue = positionOverflowingValueFrom(i, rateOfChanges2nd, maxNumScans);\n\n    var featureDetected = false;\n    if (current1stValue && previous1stValue && current2ndValue) {\n      if (previous1stValue >= 0 && current1stValue < 0) {\n        // Farest point, maxima in lidar data\n        featureDetected = true;\n      } else if (previous1stValue < 0 && current1stValue > 0.025) {\n        // Sharp edge\n        featureDetected = true;\n      }\n    }\n    var distance = currentFrame[i];\n    if (featureDetected && distance) {\n\n      var angle = angles[i];\n      var angleInRadians = Math.PI / 180 * angle;\n      var featureX = turtleState.x + Math.cos(angleInRadians) * distance;\n      var featureY = turtleState.y + Math.sin(angleInRadians) * distance;\n\n      detectedFeatures.push({\n        angle: angle - turtleState.theta,\n        distance: distance\n      });\n\n      // Mark Feature on the Map\n      context.beginPath();\n      context.strokeStyle = 'red';\n      context.fillStyle = 'red';\n      context.arc(featureX, featureY, 2, 0, 2 * Math.PI);\n      context.stroke();\n      context.closePath();\n\n      context.strokeStyle = 'lightgray';\n      context.fillStyle = 'lightgray';\n      context.beginPath();\n      context.moveTo(turtleState.x, turtleState.y);\n      context.lineTo(featureX, featureY);\n      context.stroke();\n      context.closePath();\n\n      // Mark Feature in Lidar data\n      var maxNumScans = 360 / turtleState.lidarMinResolution;\n      var rotationOffset = maxNumScans / 2;\n\n      var scanProfileX = 200 + ((i + rotationOffset) % maxNumScans);\n      var scanProfileYStart = 90;\n      var scanProfileYEnd = scanProfileYStart - rateOfChanges1st[i];\n\n      context.beginPath();\n      context.strokeStyle = 'red';\n      context.fillStyle = 'red';\n      context.arc(scanProfileX, scanProfileYEnd, 2, 0, 2 * Math.PI);\n      context.stroke();\n      context.closePath();\n\n      // Mark Feature in 1st derivative data\n      var scanProfileX = 200 + ((i + rotationOffset) % maxNumScans);\n      var scanProfileYStart = 50;\n      var scanProfileYEnd = scanProfileYStart - currentFrame[i];\n\n      context.beginPath();\n      context.strokeStyle = 'red';\n      context.fillStyle = 'red';\n      context.arc(scanProfileX, scanProfileYEnd, 2, 0, 2 * Math.PI);\n      context.stroke();\n      context.closePath();\n    }\n  }\n\n  turtleMindModel.updateParticleState(detectedFeatures);\n}\n\nvar callback = function() {\n  drawSimulation();\n  window.requestAnimationFrame(callback);\n}\n\nwindow.requestAnimationFrame(callback);\n\nwindow.addEventListener(\"keydown\", function(event) {\n  if (event.key == \"ArrowUp\") {\n\n    var dx = Math.cos(Math.PI / 180 * turtleState.theta) * 3;\n    var dy = Math.sin(Math.PI / 180 * turtleState.theta) * 3;\n\n    turtleState.x += dx;\n    turtleState.y += dy;\n\n    turtleMindModel.moveTurtleBy(dx, dy)\n  }\n  if (event.key == \"ArrowDown\") {\n    var dx = Math.cos(Math.PI / 180 * turtleState.theta) * -3;\n    var dy =  Math.sin(Math.PI / 180 * turtleState.theta) * -3;\n\n    turtleState.x += dx;\n    turtleState.y += dy;\n\n    turtleMindModel.moveTurtleBy(dx, dy)\n  }\n  if (event.key == \"ArrowLeft\") {\n    turtleState.theta -= 2;\n\n    turtleMindModel.rotateTurtle(-2);\n  }\n  if (event.key == \"ArrowRight\") {\n    turtleState.theta += 2;\n\n    turtleMindModel.rotateTurtle(2);\n  }\n});\n\n"]}