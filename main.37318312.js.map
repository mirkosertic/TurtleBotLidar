{"version":3,"sources":["js/geom.js","js/noise.js","js/envsim.js","js/derivative.js","js/main.js"],"names":["Point","x","y","anotherPoint","dx","dy","Math","sqrt","angle","distance","angleInRadians","PI","cos","sin","mx","my","Linesegment","a","b","otherLineSegment","s1_x","s1_y","s2_x","s2_y","s","t","gaussianNoise","value","u","v","random","num","log","TurtleState","location","theta","lidarLength","lidarNoise","lidarMinResolution","walls","positionOverflowingValueFrom","pos","data","maxsize","derivativeOf","offset","result","i","leftPos","rightPos","canvas","document","getElementById","context","getContext","lineWidth","strokeStyle","fillStyle","scale","translate","turtleState","turtleMindModel","particles","score","uncertainty","pow","estimatedState","undefined","length","particle","features","featureDetectionRadius","moveTurtleBy","newParticles","concat","rotateTurtle","updateParticleState","detectedFeatures","feature","push","polarProjection","j","expectedFeature","k","detectedFeature","measuredFeaturePosition","beginPath","arc","stroke","closePath","distanceTo","identified","distanceToFeature","kg","updatedNewDistance","oldLocation","meanScore","filter","index","arr","console","noiseFilter","smoothing","enabled","window","sum","process","newValue","shift","polarLine","color","rayTarget","moveTo","lineTo","renderData","xp","yp","size","shiftOffset","scaleFactor","caption","height","dataPoint","drawXPosition","drawYPositionStart","drawYPositionEnd","save","rotate","textAlign","font","fillText","restore","drawSimulation","clearRect","wall","toPrecision","currentRay","currentFrame","angles","maxNumScans","rotationOffset","lidarRayTarget","nearestIntersection","intersection","intersectionWith","wallHitPoint","scanProfileX","scanProfileYEnd","rateOfChanges1st","rateOfChanges2nd","current1stValue","previous1stValue","current2ndValue","featureDetected","featureLocation","scanProfileYStart","callback","requestAnimationFrame","addEventListener","event","key"],"mappings":"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","file":"main.37318312.js","sourceRoot":"..","sourcesContent":["/**\n * A simple point.\n */\nclass Point {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  distanceTo(anotherPoint) {\n    const dx = anotherPoint.x - this.x;\n    const dy = anotherPoint.y - this.y;\n    return Math.sqrt(dx * dx + dy * dy);\n  }\n\n  polarProjection(angle, distance) {\n    const angleInRadians = Math.PI / 180 * angle;\n    return new Point(this.x + Math.cos(angleInRadians) * distance, this.y + Math.sin(angleInRadians) * distance);\n  }\n\n  translate(mx, my) {\n    this.x += mx;\n    this.y += my;\n    return this;\n  }\n}\n\n/**\n * A line is a connection between two points.\n */\nclass Linesegment {\n  constructor(a, b) {\n    this.a = a;\n    this.b = b;\n  }\n\n  intersectionWith(otherLineSegment) {\n    const s1_x = this.b.x - this.a.x;\n    const s1_y = this.b.y - this.a.y;\n    const s2_x = otherLineSegment.b.x - otherLineSegment.a.x;\n    const s2_y = otherLineSegment.b.y - otherLineSegment.a.y;\n\n    const s = (-s1_y * (this.a.x - otherLineSegment.a.x) + s1_x * (this.a.y - otherLineSegment.a.y)) / (-s2_x * s1_y + s1_x * s2_y);\n    const t = ( s2_x * (this.a.y - otherLineSegment.a.y) - s2_y * (this.a.x - otherLineSegment.a.x)) / (-s2_x * s1_y + s1_x * s2_y);\n\n    if (s >= 0 && s <= 1 && t >= 0 && t <= 1) {\n      return new Point(this.a.x + (t * s1_x), this.a.y + (t * s1_y));\n    }\n\n    return undefined;\n  }\n}\n\nexport {Point, Linesegment};\n","function gaussianNoise(value) {\n  //return (((Math.random() + Math.random() + Math.random() + Math.random()) / 4) - 0.5) * value;\n  let u = 0, v = 0;\n  while(u === 0) u = Math.random(); //Converting [0,1) to (0,1)\n  while(v === 0) v = Math.random();\n  let num = Math.sqrt( -2.0 * Math.log( u ) ) * Math.cos( 2.0 * Math.PI * v );\n  num = num / 10.0 + 0.5; // Translate to 0 -> 1\n  if (num > 1 || num < 0) return gaussianNoise() // resample between 0 and 1\n  return (num - 0.5) * value\n}\n\nexport {gaussianNoise}\n","import {Linesegment, Point} from \"./geom.js\"\n\nclass TurtleState {\n\n  constructor() {\n    this.location = new Point(56, 56);\n    this.theta = 0;\n    this.lidarLength = 100;\n    this.lidarNoise = 0;\n    this.lidarMinResolution = 1;\n    this.walls = [\n      new Linesegment(new Point(0,0), new Point(150, 0)),\n      new Linesegment(new Point(150, 0), new Point(150, 100)),\n      new Linesegment(new Point(150, 100), new Point(0, 100)),\n      new Linesegment(new Point(0, 0), new Point(0, 100)),\n      new Linesegment(new Point(150, 80), new Point(130, 80)),\n      new Linesegment(new Point(130, 100), new Point(130, 80))\n    ];\n  }\n}\n\nexport {TurtleState};\n","function positionOverflowingValueFrom(pos, data, maxsize) {\n  if (pos < 0) {\n    pos += maxsize;\n  } else if (pos >= maxsize) {\n    pos -= maxsize;\n  }\n  return data[pos];\n}\n\nfunction derivativeOf(data,maxsize,offset) {\n  const result = []\n  for (let i = 0; i < maxsize; i++) {\n    const leftPos = positionOverflowingValueFrom(i, data, maxsize);\n    const rightPos = positionOverflowingValueFrom(i + offset, data, maxsize);\n    if (leftPos && rightPos) {\n      result[i] = (rightPos - leftPos);\n    }\n  }\n  return result;\n}\n\nexport {derivativeOf, positionOverflowingValueFrom};\n","import {Point, Linesegment} from \"./geom.js\";\nimport {gaussianNoise} from \"./noise.js\";\nimport {TurtleState} from \"./envsim.js\";\nimport {derivativeOf, positionOverflowingValueFrom} from \"./derivative.js\";\n\nconst canvas = document.getElementById(\"rendering\");\nconst context = canvas.getContext(\"2d\");\n\ncontext.lineWidth = 1;\ncontext.strokeStyle = 'black';\ncontext.fillStyle = 'black';\ncontext.scale(2, 2);\ncontext.translate(100, 100);\n\nconst turtleState = new TurtleState();\n\nconst turtleMindModel = {\n  particles: [\n    {\n      location: new Point(0, 0),\n      theta: 0,\n      score: 1,\n      uncertainty: Math.pow(10, 2)\n    }\n  ],\n  estimatedState: function () {\n    var x = undefined;\n    var y = undefined;\n    var theta = undefined;\n    var uncertainty = undefined;\n    for (let i = 0; i < this.particles.length; i++) {\n      const particle = this.particles[i];\n      if (x) {\n        x = (x + particle.location.x) / 2;\n      } else {\n        x = particle.location.x;\n      }\n      if (y) {\n        y = (y + particle.location.y) / 2;\n      } else {\n        y = particle.location.y;\n      }\n      if (theta) {\n        theta = (theta + particle.theta) / 2;\n      } else {\n        theta = particle.theta;\n      }\n      if (uncertainty) {\n        uncertainty = (uncertainty + particle.uncertainty) / 2;\n      } else {\n        uncertainty = particle.uncertainty;\n      }\n    }\n    return {\n      location: new Point(x, y),\n      theta: theta,\n      uncertainty: uncertainty\n    }\n  },\n  features: [],\n  featureDetectionRadius: 3,\n\n  moveTurtleBy: function (dx, dy) {\n    const newParticles = [];\n    for (let i = 0; i < this.particles.length; i++) {\n      const particle = this.particles[i];\n      particle.location.translate(dx + gaussianNoise(3), dy + gaussianNoise(3));\n      particle.uncertainty = Math.pow(10, 2)\n    }\n    this.particles = this.particles.concat(newParticles);\n  },\n\n  rotateTurtle: function (angle) {\n    const newParticles = [];\n    for (let i = 0; i < this.particles.length; i++) {\n      const particle = this.particles[i];\n      particle.theta += angle;\n      particle.uncertainty = Math.pow(10, 2)\n    }\n    this.particles = this.particles.concat(newParticles);\n  },\n  updateParticleState: function (detectedFeatures) {\n    const estimatedState = turtleMindModel.estimatedState();\n\n    // If we do not have features, we initially add the found one to our map\n    if (this.features.length === 0) {\n      for (let i = 0; i < detectedFeatures.length; i++) {\n        const feature = detectedFeatures[i];\n        this.features.push({\n            uncertainty: Math.pow(10, 2),\n            location: estimatedState.location.polarProjection(feature.angle + estimatedState.theta, feature.distance)\n        });\n      }\n    } else {\n      // Now comes the tricky part: we evaluate the found features against\n      // every particle and verify the expectations\n      for (let i = 0; i < this.particles.length; i++) {\n        const particle = this.particles[i];\n        particle.score = 0;\n        for (let j = 0; j < this.features.length; j++) {\n          const expectedFeature = this.features[j];\n\n          // Now we check, if there is such a feature\n          for (let k = 0; k < detectedFeatures.length; k++) {\n            const detectedFeature = detectedFeatures[k];\n\n            const featureProjection = new Point(0, 0).polarProjection(detectedFeature.angle + particle.theta, detectedFeature.distance);\n\n            // This is what we have measured\n            const measuredFeaturePosition = featureProjection.translate(particle.location.x, particle.location.y);\n\n            context.beginPath();\n            context.strokeStyle = 'gray';\n            context.fillStyle = 'gray';\n            context.arc(56 + measuredFeaturePosition.x, 200 + measuredFeaturePosition.y, 8, 0, 2 * Math.PI);\n            context.stroke();\n            context.closePath();\n\n            const distance = measuredFeaturePosition.distanceTo(expectedFeature.location);\n\n            if (distance < 10) {\n              detectedFeature.identified = true;\n\n              // This is what we have found\n              context.beginPath();\n              context.strokeStyle = 'blue';\n              context.fillStyle = 'blue';\n              context.arc(56 + measuredFeaturePosition.x, 200 + measuredFeaturePosition.y, 6, 0, 2 * Math.PI);\n              context.stroke();\n              context.closePath();\n\n              // Maybe a match, the particle gets a hit point\n              particle.score += 1;\n\n              //\n              // Kalman filter\n              //\n\n              // Previous state, distance to feature\n              const distanceToFeature = expectedFeature.location.distanceTo(particle.location);\n\n              // We calculate the Kalman gain\n              const kg = estimatedState.uncertainty / (estimatedState.uncertainty + detectedFeature.uncertainty);\n\n              // Uncertainty update\n              particle.uncertainty = (1 - kg) * estimatedState.uncertainty;\n\n              // Estimate the new distance based on previous state and current measurement\n              const updatedNewDistance = distanceToFeature + kg * (detectedFeature.distance - distanceToFeature);\n\n              const oldLocation = particle.location;\n\n              // Backprojection of new distance from feature to get the new estimated position\n              particle.location = expectedFeature.location.polarProjection(detectedFeature.angle + particle.theta + 180, updatedNewDistance);\n              expectedFeature.location = oldLocation.polarProjection(detectedFeature.angle + particle.theta, updatedNewDistance);\n            }\n          }\n        }\n      }\n      // We calculate the mean score\n      var meanScore = undefined;\n      for (let i = 0; i < this.particles.length; i++) {\n        if (meanScore) {\n          meanScore = (meanScore + this.particles[i].score) / 2;\n        } else {\n          meanScore = this.particles[i].score;\n        }\n      }\n\n      // We are done here, now we evaluate dead particles\n      this.particles = this.particles.filter(function (value, index, arr) {\n        if (value.score >= meanScore) {\n          return true;\n        } else {\n          console.log(\"Particle \" + index + \" got score \" + value.score + \" from \" + detectedFeatures.length + \" and will be removed!\");\n          return false;\n        }\n      });\n    }\n  }\n};\n\nconst noiseFilter = {\n  smoothing : 2,\n  enabled: false,\n  window: [],\n  sum: undefined,\n\n  process: function(pos, newValue) {\n    if (this.enabled) {\n      if (this.sum) {\n        this.sum += newValue;\n      } else {\n        this.sum = newValue;\n      }\n      this.window.push(newValue);\n      if (this.window.length <= this.smoothing) {\n        return this.sum / this.window.length;\n      }\n      this.sum -= this.window.shift();\n      return this.sum / this.smoothing;\n    } else {\n      return newValue;\n    }\n  }\n}\n\nfunction polarLine(location, angle, length, color) {\n  const rayTarget = location.polarProjection(angle, length);\n  context.strokeStyle = color;\n  context.fillStyle = color;\n  context.beginPath();\n  context.moveTo(location.x, location.y);\n  context.lineTo(rayTarget.x, rayTarget.y);\n  context.stroke();\n  context.closePath();\n}\n\nfunction renderData(xp, yp, color, data, size, shiftOffset, scaleFactor, caption, height) {\n\n  for (let i = 0; i < size; i++) {\n\n    const dataPoint = data[i];\n    if (dataPoint) {\n\n      const drawXPosition = xp + ((i + shiftOffset) % size);\n      const drawYPositionStart = yp;\n      const drawYPositionEnd = drawYPositionStart + dataPoint * scaleFactor;\n\n      context.beginPath();\n      context.strokeStyle = color;\n      context.fillStyle = color;\n\n      context.moveTo(drawXPosition, drawYPositionStart);\n      context.lineTo(drawXPosition, drawYPositionEnd);\n\n      context.stroke();\n      context.closePath();\n    }\n  }\n\n  context.save();\n\n  context.beginPath();\n  context.strokeStyle = 'black';\n  context.fillStyle = 'black';\n\n  context.moveTo(xp, yp - height);\n  context.lineTo(xp, yp + height);\n\n  context.translate(xp, yp);\n  context.rotate(-Math.PI / 2);\n  context.textAlign = 'center';\n  context.font = \"8px Arial\";\n  context.fillText(caption, 0, -5);\n\n  context.stroke();\n  context.closePath();\n\n  context.restore();\n}\n\nfunction drawSimulation() {\n\n  context.clearRect(-100, -100, 1000, 1000);\n\n  // Render reality\n  context.strokeStyle = 'black';\n  context.fillStyle = 'black';\n  context.textAlign = 'left';\n  context.font = \"8px Arial\";\n  context.fillText('Reality', -20, -20);\n\n  // Draw the walls\n  context.strokeStyle = 'black';\n  context.fillStyle = 'black';\n  context.beginPath();\n  for (let i = 0; i < turtleState.walls.length; i++) {\n    const wall = turtleState.walls[i];\n    context.moveTo(wall.a.x, wall.a.y);\n    context.lineTo(wall.b.x, wall.b.y);\n  }\n  context.stroke();\n  context.closePath();\n\n  // Draw the turtle\n  context.beginPath();\n  context.strokeStyle = 'gray';\n  context.fillStyle = 'gray';\n  context.arc(turtleState.location.x, turtleState.location.y, 8, 0, 2 * Math.PI);\n  context.stroke();\n  context.closePath();\n\n  polarLine(turtleState.location, turtleState.theta, 20, 'green');\n\n  // Render turtles model\n  context.strokeStyle = 'black';\n  context.fillStyle = 'black';\n  context.textAlign = 'left';\n  context.font = \"8px Arial\";\n  context.fillText('Turtles model no.F. = ' + turtleMindModel.features.length + \", no. P = \" + turtleMindModel.particles.length, -20, 120);\n\n  for (let i = 0; i < turtleMindModel.particles.length; i++) {\n    const particle = turtleMindModel.particles[i];\n    context.beginPath();\n    context.strokeStyle = 'gray';\n    context.fillStyle = 'gray';\n    context.arc(particle.location.x + 56, particle.location.y + 200, 8, 0, 2 * Math.PI);\n    context.stroke();\n    context.closePath();\n    polarLine(new Point(particle.location.x + 56, particle.location.y + 200), particle.theta, 20, 'green');\n\n    context.strokeStyle = 'black';\n    context.fillStyle = 'black';\n    context.textAlign = 'left';\n    context.font = \"8px Arial\";\n    context.fillText('Uncertainty:', particle.location.x + 46, particle.location.y + 170);\n    context.fillText(particle.uncertainty.toPrecision(4), particle.location.x + 46, particle.location.y + 180);\n  }\n\n  for (let i = 0; i < turtleMindModel.features.length; i++) {\n    const feature = turtleMindModel.features[i];\n    context.beginPath();\n    context.strokeStyle = 'red';\n    context.fillStyle = 'red';\n    context.arc(feature.location.x - 1 + 56, feature.location.y -1 + 200, 3, 0, 2 * Math.PI);\n    context.stroke();\n    context.closePath();\n  }\n\n  var currentRay = 0;\n  const currentFrame = [];\n  const angles = [];\n\n  const maxNumScans = 360 / turtleState.lidarMinResolution;\n  const rotationOffset = maxNumScans / 2;\n\n  for (let i = turtleState.theta; i < turtleState.theta + 360; i += turtleState.lidarMinResolution, currentRay++) {\n\n    const lidarRayTarget = turtleState.location.polarProjection(i, turtleState.lidarLength);\n\n    var nearestIntersection = undefined;\n    for (let j = 0; j < turtleState.walls.length; j++) {\n      const wall = turtleState.walls[j];\n      const intersection = wall.intersectionWith(new Linesegment(turtleState.location, lidarRayTarget));\n      if (intersection) {\n        const distance = noiseFilter.process(currentRay, turtleState.location.distanceTo(intersection) + gaussianNoise(turtleState.lidarNoise));\n        if (nearestIntersection) {\n          if (nearestIntersection.distance > distance) {\n            nearestIntersection = {\n              distance: distance,\n              intersection: intersection\n            };\n          }\n        } else {\n          nearestIntersection = {\n            distance: distance,\n            intersection: intersection\n          }\n        }\n      }\n    }\n\n    if (nearestIntersection) {\n\n      currentFrame[currentRay] = nearestIntersection.distance;\n      angles[currentRay] = i;\n\n      // Do some back projection\n      const wallHitPoint = turtleState.location.polarProjection(i, nearestIntersection.distance);\n\n      context.beginPath();\n      context.strokeStyle = 'CadetBlue';\n      context.fillStyle = 'CadetBlue';\n      context.arc(wallHitPoint.x, wallHitPoint.y, 2, 0, 2 * Math.PI);\n      context.stroke();\n      context.closePath();\n\n      context.beginPath();\n      if (currentRay === 0) {\n        context.strokeStyle = 'green';\n        context.fillStyle = 'green';\n      } else {\n        context.strokeStyle = 'CadetBlue';\n        context.fillStyle = 'CadetBlue';\n      }\n\n      const scanProfileX = 200 + ((currentRay + rotationOffset) % maxNumScans);\n      const scanProfileYStart = 50;\n      const scanProfileYEnd = scanProfileYStart - nearestIntersection.distance;\n\n      context.moveTo(scanProfileX, scanProfileYStart);\n      context.lineTo(scanProfileX, scanProfileYEnd);\n\n      context.stroke();\n      context.closePath();\n\n    } else {\n      context.strokeStyle = 'rgba(128,128,128,0.05)';\n      context.fillStyle = 'rgba(128,128,128,0.05)';\n      context.beginPath();\n      context.moveTo(turtleState.location.x, turtleState.location.y);\n      context.lineTo(lidarRayTarget.x, lidarRayTarget.y);\n      context.stroke();\n      context.closePath();\n    }\n  }\n\n  context.save();\n  context.beginPath();\n  context.strokeStyle = 'black';\n  context.fillStyle = 'black';\n  context.moveTo(200, 50);\n  context.lineTo(200, 50 - 120);\n  context.translate(200, 50);\n  context.rotate(-Math.PI / 2);\n  context.textAlign = 'center';\n  context.font = \"8px Arial\";\n  context.fillText('Lidar distance', 60, -5);\n  context.stroke();\n  context.closePath();\n  context.restore();\n\n  const rateOfChanges1st = derivativeOf(currentFrame, currentRay, 1);\n  const rateOfChanges2nd = derivativeOf(rateOfChanges1st, currentRay, 1);\n\n  // Render derivatives\n  renderData(200, 90, 'DarkSlateGrey', rateOfChanges1st, maxNumScans, rotationOffset, 3, '1st derivative', 20);\n  renderData(200, 160, 'DarkSlateGrey', rateOfChanges2nd, maxNumScans, rotationOffset, 15, '2nd derivative',20);\n\n  const detectedFeatures = [];\n\n  // Check for maxima and sharp edges\n  for (let i = 0; i < currentRay; i++) {\n    const current1stValue = positionOverflowingValueFrom(i, rateOfChanges1st, maxNumScans);\n    const previous1stValue = positionOverflowingValueFrom(i - 1, rateOfChanges1st, maxNumScans);\n\n    const current2ndValue = positionOverflowingValueFrom(i, rateOfChanges2nd, maxNumScans);\n\n    var featureDetected = false;\n    if (current1stValue && previous1stValue && current2ndValue) {\n      if (previous1stValue >= 0 && current1stValue < 0) {\n        // Farest point, maxima in lidar data\n        featureDetected = true;\n      } else if (previous1stValue < 0 && current1stValue > 0.025) {\n        // Sharp edge\n        featureDetected = true;\n      }\n    }\n    const distance = currentFrame[i];\n    if (featureDetected && distance) {\n\n      const angle = angles[i];\n      const featureLocation = turtleState.location.polarProjection(angle, distance);\n\n      detectedFeatures.push({\n        angle: angle - turtleState.theta,\n        distance: distance,\n        uncertainty: Math.pow(5, 2)\n      });\n\n      // Mark Feature on the Map\n      context.beginPath();\n      context.strokeStyle = 'red';\n      context.fillStyle = 'red';\n      context.arc(featureLocation.x, featureLocation.y, 2, 0, 2 * Math.PI);\n      context.stroke();\n      context.closePath();\n\n      context.strokeStyle = 'lightgray';\n      context.fillStyle = 'lightgray';\n      context.beginPath();\n      context.moveTo(turtleState.location.x, turtleState.location.y);\n      context.lineTo(featureLocation.x, featureLocation.y);\n      context.stroke();\n      context.closePath();\n\n      // Mark Feature in Lidar data\n      let scanProfileX = 200 + ((i + rotationOffset) % maxNumScans);\n      let scanProfileYStart = 90;\n      let scanProfileYEnd = scanProfileYStart - rateOfChanges1st[i];\n\n      context.beginPath();\n      context.strokeStyle = 'red';\n      context.fillStyle = 'red';\n      context.arc(scanProfileX, scanProfileYEnd, 2, 0, 2 * Math.PI);\n      context.stroke();\n      context.closePath();\n\n      // Mark Feature in 1st derivative data\n      scanProfileX = 200 + ((i + rotationOffset) % maxNumScans);\n      scanProfileYStart = 50;\n      scanProfileYEnd = scanProfileYStart - currentFrame[i];\n\n      context.beginPath();\n      context.strokeStyle = 'red';\n      context.fillStyle = 'red';\n      context.arc(scanProfileX, scanProfileYEnd, 2, 0, 2 * Math.PI);\n      context.stroke();\n      context.closePath();\n    }\n  }\n\n  turtleMindModel.updateParticleState(detectedFeatures);\n}\n\nfunction callback() {\n  drawSimulation();\n  window.requestAnimationFrame(callback);\n}\n\nwindow.requestAnimationFrame(callback);\n\nwindow.addEventListener(\"keydown\", function(event) {\n  if (event.key === \"ArrowUp\") {\n\n    const dx = Math.cos(Math.PI / 180 * turtleState.theta) * 3;\n    const dy = Math.sin(Math.PI / 180 * turtleState.theta) * 3;\n\n    turtleState.location.translate(dx, dy);\n\n    turtleMindModel.moveTurtleBy(dx, dy)\n  }\n  if (event.key === \"ArrowDown\") {\n    const dx = Math.cos(Math.PI / 180 * turtleState.theta) * -3;\n    const dy =  Math.sin(Math.PI / 180 * turtleState.theta) * -3;\n\n    turtleState.location.translate(dx, dy);\n\n    turtleMindModel.moveTurtleBy(dx, dy)\n  }\n  if (event.key === \"ArrowLeft\") {\n    turtleState.theta -= 2;\n\n    turtleMindModel.rotateTurtle(-2);\n  }\n  if (event.key === \"ArrowRight\") {\n    turtleState.theta += 2;\n\n    turtleMindModel.rotateTurtle(2);\n  }\n});\n\n"]}