{"version":3,"sources":["js/geom.js","js/noise.js","js/envsim.js","js/derivative.js","js/main.js"],"names":["Point","x","y","anotherPoint","dx","dy","Math","sqrt","angle","distance","angleInRadians","PI","cos","sin","mx","my","Linesegment","a","b","otherLineSegment","s1_x","s1_y","s2_x","s2_y","s","t","gaussianNoise","value","u","v","random","num","log","TurtleState","location","theta","lidarLength","lidarNoise","lidarMinResolution","lidarSampleCount","walls","distances","angles","currentRay","i","lidarRayTarget","polarProjection","nearestIntersection","undefined","j","length","wall","intersection","intersectionWith","distanceTo","k","positionOverflowingValueFrom","pos","data","maxsize","derivativeOf","offset","result","leftPos","rightPos","canvas","document","getElementById","context","getContext","lineWidth","strokeStyle","fillStyle","scale","translate","turtleState","turtleMindModel","particles","score","uncertainty","pow","estimatedState","particle","features","featureDetectionRadius","moveTurtleBy","newParticles","concat","rotateTurtle","updateParticleState","detectedFeatures","feature","push","expectedFeature","detectedFeature","measuredFeaturePosition","beginPath","arc","stroke","closePath","identified","distanceToFeature","kg","updatedNewDistance","oldLocation","meanScore","filter","index","arr","console","polarLine","color","rayTarget","moveTo","lineTo","renderData","xp","yp","size","shiftOffset","scaleFactor","caption","height","dataPoint","drawXPosition","drawYPositionStart","drawYPositionEnd","save","rotate","textAlign","font","fillText","restore","drawSimulation","clearRect","toPrecision","lidarFrame","currentFrame","maxNumScans","rotationOffset","wallHitPoint","scanProfileX","scanProfileYEnd","rateOfChanges1st","rateOfChanges2nd","current1stValue","previous1stValue","current2ndValue","featureDetected","featureLocation","scanProfileYStart","callback","window","requestAnimationFrame","addEventListener","event","key"],"mappings":"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","file":"main.f57e4fc7.js","sourceRoot":"..","sourcesContent":["/**\n * A simple point.\n */\nclass Point {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  distanceTo(anotherPoint) {\n    const dx = anotherPoint.x - this.x;\n    const dy = anotherPoint.y - this.y;\n    return Math.sqrt(dx * dx + dy * dy);\n  }\n\n  polarProjection(angle, distance) {\n    const angleInRadians = Math.PI / 180 * angle;\n    return new Point(this.x + Math.cos(angleInRadians) * distance, this.y + Math.sin(angleInRadians) * distance);\n  }\n\n  translate(mx, my) {\n    this.x += mx;\n    this.y += my;\n    return this;\n  }\n}\n\n/**\n * A line is a connection between two points.\n */\nclass Linesegment {\n  constructor(a, b) {\n    this.a = a;\n    this.b = b;\n  }\n\n  intersectionWith(otherLineSegment) {\n    const s1_x = this.b.x - this.a.x;\n    const s1_y = this.b.y - this.a.y;\n    const s2_x = otherLineSegment.b.x - otherLineSegment.a.x;\n    const s2_y = otherLineSegment.b.y - otherLineSegment.a.y;\n\n    const s = (-s1_y * (this.a.x - otherLineSegment.a.x) + s1_x * (this.a.y - otherLineSegment.a.y)) / (-s2_x * s1_y + s1_x * s2_y);\n    const t = ( s2_x * (this.a.y - otherLineSegment.a.y) - s2_y * (this.a.x - otherLineSegment.a.x)) / (-s2_x * s1_y + s1_x * s2_y);\n\n    if (s >= 0 && s <= 1 && t >= 0 && t <= 1) {\n      return new Point(this.a.x + (t * s1_x), this.a.y + (t * s1_y));\n    }\n\n    return undefined;\n  }\n}\n\nexport {Point, Linesegment};\n","function gaussianNoise(value) {\n  //return (((Math.random() + Math.random() + Math.random() + Math.random()) / 4) - 0.5) * value;\n  let u = 0, v = 0;\n  while(u === 0) u = Math.random(); //Converting [0,1) to (0,1)\n  while(v === 0) v = Math.random();\n  let num = Math.sqrt( -2.0 * Math.log( u ) ) * Math.cos( 2.0 * Math.PI * v );\n  num = num / 10.0 + 0.5; // Translate to 0 -> 1\n  if (num > 1 || num < 0) return gaussianNoise() // resample between 0 and 1\n  return (num - 0.5) * value\n}\n\nexport {gaussianNoise}\n","import {Linesegment, Point} from \"./geom.js\"\nimport {gaussianNoise} from \"./noise\";\n\nclass TurtleState {\n\n  constructor() {\n    this.location = new Point(56, 56);\n    this.theta = 0;\n    this.lidarLength = 100;\n    this.lidarNoise = 0;\n    this.lidarMinResolution = 1;\n    this.lidarSampleCount = 0;\n    this.walls = [\n      new Linesegment(new Point(0,0), new Point(150, 0)),\n      new Linesegment(new Point(150, 0), new Point(150, 100)),\n      new Linesegment(new Point(150, 100), new Point(0, 100)),\n      new Linesegment(new Point(0, 0), new Point(0, 100)),\n      new Linesegment(new Point(150, 80), new Point(130, 80)),\n      new Linesegment(new Point(130, 100), new Point(130, 80))\n    ];\n  }\n\n  lidarFrame() {\n    const distances = [];\n    const angles = [];\n\n    let currentRay = 0;\n    for (let i = this.theta; i < this.theta + 360; i += this.lidarMinResolution, currentRay++) {\n      angles[currentRay] = i;\n\n      const lidarRayTarget = this.location.polarProjection(i, this.lidarLength);\n\n      var nearestIntersection = undefined;\n      for (let j = 0; j < this.walls.length; j++) {\n        const wall = this.walls[j];\n        const intersection = wall.intersectionWith(new Linesegment(this.location, lidarRayTarget));\n        if (intersection) {\n          let distance = this.location.distanceTo(intersection) + gaussianNoise(this.lidarNoise);\n          // Now, we take more samples to average out noise\n          for (let k = 0; k < this.lidarSampleCount; k++) {\n            let newMeasure = this.location.distanceTo(intersection) + gaussianNoise(this.lidarNoise);\n            distance = (distance + newMeasure) / 2;\n          }\n          if (nearestIntersection) {\n            if (nearestIntersection.distance > distance) {\n              nearestIntersection = {\n                distance: distance,\n                intersection: intersection\n              };\n            }\n          } else {\n            nearestIntersection = {\n              distance: distance,\n              intersection: intersection\n            }\n          }\n        }\n      }\n\n      if (nearestIntersection) {\n        distances[currentRay] = nearestIntersection.distance;\n      }\n    }\n\n    return {\n      angles: angles,\n      distances: distances\n    }\n  }\n}\n\nexport {TurtleState};\n","function positionOverflowingValueFrom(pos, data, maxsize) {\n  if (pos < 0) {\n    pos += maxsize;\n  } else if (pos >= maxsize) {\n    pos -= maxsize;\n  }\n  return data[pos];\n}\n\nfunction derivativeOf(data,maxsize,offset) {\n  const result = []\n  for (let i = 0; i < maxsize; i++) {\n    const leftPos = positionOverflowingValueFrom(i, data, maxsize);\n    const rightPos = positionOverflowingValueFrom(i + offset, data, maxsize);\n    if (leftPos && rightPos) {\n      result[i] = (rightPos - leftPos);\n    }\n  }\n  return result;\n}\n\nexport {derivativeOf, positionOverflowingValueFrom};\n","import {Point, Linesegment} from \"./geom.js\";\nimport {gaussianNoise} from \"./noise.js\";\nimport {TurtleState} from \"./envsim.js\";\nimport {derivativeOf, positionOverflowingValueFrom} from \"./derivative.js\";\n\nconst canvas = document.getElementById(\"rendering\");\nconst context = canvas.getContext(\"2d\");\n\ncontext.lineWidth = 1;\ncontext.strokeStyle = 'black';\ncontext.fillStyle = 'black';\ncontext.scale(2, 2);\ncontext.translate(100, 100);\n\nconst turtleState = new TurtleState();\n\nconst turtleMindModel = {\n  particles: [\n    {\n      location: new Point(0, 0),\n      theta: 0,\n      score: 1,\n      uncertainty: Math.pow(10, 2)\n    }\n  ],\n  estimatedState: function () {\n    var x = undefined;\n    var y = undefined;\n    var theta = undefined;\n    var uncertainty = undefined;\n    for (let i = 0; i < this.particles.length; i++) {\n      const particle = this.particles[i];\n      if (x) {\n        x = (x + particle.location.x) / 2;\n      } else {\n        x = particle.location.x;\n      }\n      if (y) {\n        y = (y + particle.location.y) / 2;\n      } else {\n        y = particle.location.y;\n      }\n      if (theta) {\n        theta = (theta + particle.theta) / 2;\n      } else {\n        theta = particle.theta;\n      }\n      if (uncertainty) {\n        uncertainty = (uncertainty + particle.uncertainty) / 2;\n      } else {\n        uncertainty = particle.uncertainty;\n      }\n    }\n    return {\n      location: new Point(x, y),\n      theta: theta,\n      uncertainty: uncertainty\n    }\n  },\n  features: [],\n  featureDetectionRadius: 3,\n\n  moveTurtleBy: function (dx, dy) {\n    const newParticles = [];\n    for (let i = 0; i < this.particles.length; i++) {\n      const particle = this.particles[i];\n      particle.location.translate(dx + gaussianNoise(3), dy + gaussianNoise(3));\n      particle.uncertainty = Math.pow(10, 2)\n    }\n    this.particles = this.particles.concat(newParticles);\n  },\n\n  rotateTurtle: function (angle) {\n    const newParticles = [];\n    for (let i = 0; i < this.particles.length; i++) {\n      const particle = this.particles[i];\n      particle.theta += angle;\n      particle.uncertainty = Math.pow(10, 2)\n    }\n    this.particles = this.particles.concat(newParticles);\n  },\n  updateParticleState: function (detectedFeatures) {\n    const estimatedState = turtleMindModel.estimatedState();\n\n    // If we do not have features, we initially add the found one to our map\n    if (this.features.length === 0) {\n      for (let i = 0; i < detectedFeatures.length; i++) {\n        const feature = detectedFeatures[i];\n        this.features.push({\n            uncertainty: Math.pow(10, 2),\n            location: estimatedState.location.polarProjection(feature.angle + estimatedState.theta, feature.distance)\n        });\n      }\n    } else {\n      // Now comes the tricky part: we evaluate the found features against\n      // every particle and verify the expectations\n      for (let i = 0; i < this.particles.length; i++) {\n        const particle = this.particles[i];\n        particle.score = 0;\n        for (let j = 0; j < this.features.length; j++) {\n          const expectedFeature = this.features[j];\n\n          // Now we check, if there is such a feature\n          for (let k = 0; k < detectedFeatures.length; k++) {\n            const detectedFeature = detectedFeatures[k];\n\n            const featureProjection = new Point(0, 0).polarProjection(detectedFeature.angle + particle.theta, detectedFeature.distance);\n\n            // This is what we have measured\n            const measuredFeaturePosition = featureProjection.translate(particle.location.x, particle.location.y);\n\n            context.beginPath();\n            context.strokeStyle = 'gray';\n            context.fillStyle = 'gray';\n            context.arc(56 + measuredFeaturePosition.x, 200 + measuredFeaturePosition.y, 8, 0, 2 * Math.PI);\n            context.stroke();\n            context.closePath();\n\n            const distance = measuredFeaturePosition.distanceTo(expectedFeature.location);\n\n            if (distance < 10) {\n              detectedFeature.identified = true;\n\n              // This is what we have found\n              context.beginPath();\n              context.strokeStyle = 'blue';\n              context.fillStyle = 'blue';\n              context.arc(56 + measuredFeaturePosition.x, 200 + measuredFeaturePosition.y, 6, 0, 2 * Math.PI);\n              context.stroke();\n              context.closePath();\n\n              // Maybe a match, the particle gets a hit point\n              particle.score += 1;\n\n              //\n              // Kalman filter\n              //\n\n              // Previous state, distance to feature\n              const distanceToFeature = expectedFeature.location.distanceTo(particle.location);\n\n              // We calculate the Kalman gain\n              const kg = estimatedState.uncertainty / (estimatedState.uncertainty + detectedFeature.uncertainty);\n\n              // Uncertainty update\n              particle.uncertainty = (1 - kg) * estimatedState.uncertainty;\n\n              // Estimate the new distance based on previous state and current measurement\n              const updatedNewDistance = distanceToFeature + kg * (detectedFeature.distance - distanceToFeature);\n\n              const oldLocation = particle.location;\n\n              // Backprojection of new distance from feature to get the new estimated position\n              particle.location = expectedFeature.location.polarProjection(detectedFeature.angle + particle.theta + 180, updatedNewDistance);\n              expectedFeature.location = oldLocation.polarProjection(detectedFeature.angle + particle.theta, updatedNewDistance);\n            }\n          }\n        }\n      }\n      // We calculate the mean score\n      var meanScore = undefined;\n      for (let i = 0; i < this.particles.length; i++) {\n        if (meanScore) {\n          meanScore = (meanScore + this.particles[i].score) / 2;\n        } else {\n          meanScore = this.particles[i].score;\n        }\n      }\n\n      // We are done here, now we evaluate dead particles\n      this.particles = this.particles.filter(function (value, index, arr) {\n        if (value.score >= meanScore) {\n          return true;\n        } else {\n          console.log(\"Particle \" + index + \" got score \" + value.score + \" from \" + detectedFeatures.length + \" and will be removed!\");\n          return false;\n        }\n      });\n    }\n  }\n};\n\nfunction polarLine(location, angle, length, color) {\n  const rayTarget = location.polarProjection(angle, length);\n  context.strokeStyle = color;\n  context.fillStyle = color;\n  context.beginPath();\n  context.moveTo(location.x, location.y);\n  context.lineTo(rayTarget.x, rayTarget.y);\n  context.stroke();\n  context.closePath();\n}\n\nfunction renderData(xp, yp, color, data, size, shiftOffset, scaleFactor, caption, height) {\n\n  for (let i = 0; i < size; i++) {\n\n    const dataPoint = data[i];\n    if (dataPoint) {\n\n      const drawXPosition = xp + ((i + shiftOffset) % size);\n      const drawYPositionStart = yp;\n      const drawYPositionEnd = drawYPositionStart + dataPoint * scaleFactor;\n\n      context.beginPath();\n      context.strokeStyle = color;\n      context.fillStyle = color;\n\n      context.moveTo(drawXPosition, drawYPositionStart);\n      context.lineTo(drawXPosition, drawYPositionEnd);\n\n      context.stroke();\n      context.closePath();\n    }\n  }\n\n  context.save();\n\n  context.beginPath();\n  context.strokeStyle = 'black';\n  context.fillStyle = 'black';\n\n  context.moveTo(xp, yp - height);\n  context.lineTo(xp, yp + height);\n\n  context.translate(xp, yp);\n  context.rotate(-Math.PI / 2);\n  context.textAlign = 'center';\n  context.font = \"8px Arial\";\n  context.fillText(caption, 0, -5);\n\n  context.stroke();\n  context.closePath();\n\n  context.restore();\n}\n\nfunction drawSimulation() {\n\n  context.clearRect(-100, -100, 1000, 1000);\n\n  // Render reality\n  context.strokeStyle = 'black';\n  context.fillStyle = 'black';\n  context.textAlign = 'left';\n  context.font = \"8px Arial\";\n  context.fillText('Reality', -20, -20);\n\n  // Draw the walls\n  context.strokeStyle = 'black';\n  context.fillStyle = 'black';\n  context.beginPath();\n  for (let i = 0; i < turtleState.walls.length; i++) {\n    const wall = turtleState.walls[i];\n    context.moveTo(wall.a.x, wall.a.y);\n    context.lineTo(wall.b.x, wall.b.y);\n  }\n  context.stroke();\n  context.closePath();\n\n  // Draw the turtle\n  context.beginPath();\n  context.strokeStyle = 'gray';\n  context.fillStyle = 'gray';\n  context.arc(turtleState.location.x, turtleState.location.y, 8, 0, 2 * Math.PI);\n  context.stroke();\n  context.closePath();\n\n  polarLine(turtleState.location, turtleState.theta, 20, 'green');\n\n  // Render turtles model\n  context.strokeStyle = 'black';\n  context.fillStyle = 'black';\n  context.textAlign = 'left';\n  context.font = \"8px Arial\";\n  context.fillText('Turtles model no.F. = ' + turtleMindModel.features.length + \", no. P = \" + turtleMindModel.particles.length, -20, 120);\n\n  for (let i = 0; i < turtleMindModel.particles.length; i++) {\n    const particle = turtleMindModel.particles[i];\n    context.beginPath();\n    context.strokeStyle = 'gray';\n    context.fillStyle = 'gray';\n    context.arc(particle.location.x + 56, particle.location.y + 200, 8, 0, 2 * Math.PI);\n    context.stroke();\n    context.closePath();\n    polarLine(new Point(particle.location.x + 56, particle.location.y + 200), particle.theta, 20, 'green');\n\n    context.strokeStyle = 'black';\n    context.fillStyle = 'black';\n    context.textAlign = 'left';\n    context.font = \"8px Arial\";\n    context.fillText('Uncertainty:', particle.location.x + 46, particle.location.y + 170);\n    context.fillText(particle.uncertainty.toPrecision(4), particle.location.x + 46, particle.location.y + 180);\n  }\n\n  for (let i = 0; i < turtleMindModel.features.length; i++) {\n    const feature = turtleMindModel.features[i];\n    context.beginPath();\n    context.strokeStyle = 'red';\n    context.fillStyle = 'red';\n    context.arc(feature.location.x - 1 + 56, feature.location.y -1 + 200, 3, 0, 2 * Math.PI);\n    context.stroke();\n    context.closePath();\n  }\n\n  const lidarFrame = turtleState.lidarFrame();\n\n  const currentRay = lidarFrame.angles.length;\n  const currentFrame = lidarFrame.distances;\n  const angles = lidarFrame.angles;\n\n  const maxNumScans = 360 / turtleState.lidarMinResolution;\n  const rotationOffset = maxNumScans / 2;\n\n  for (let i = 0; i < currentRay; i += 1) {\n\n    const lidarRayTarget = turtleState.location.polarProjection(i + turtleState.theta, turtleState.lidarLength);\n\n    const distance = currentFrame[i];\n    if (distance) {\n      const wallHitPoint = turtleState.location.polarProjection(i + turtleState.theta, distance);\n\n      context.beginPath();\n      context.strokeStyle = 'CadetBlue';\n      context.fillStyle = 'CadetBlue';\n      context.arc(wallHitPoint.x, wallHitPoint.y, 2, 0, 2 * Math.PI);\n      context.stroke();\n      context.closePath();\n\n      context.beginPath();\n      if (currentRay === 0) {\n        context.strokeStyle = 'green';\n        context.fillStyle = 'green';\n      } else {\n        context.strokeStyle = 'CadetBlue';\n        context.fillStyle = 'CadetBlue';\n      }\n\n      const scanProfileX = 200 + ((i + rotationOffset) % maxNumScans);\n      const scanProfileYStart = 50;\n      const scanProfileYEnd = scanProfileYStart - distance;\n\n      context.moveTo(scanProfileX, scanProfileYStart);\n      context.lineTo(scanProfileX, scanProfileYEnd);\n\n      context.stroke();\n      context.closePath();\n\n    } else {\n\n      context.strokeStyle = 'rgba(128,128,128,0.05)';\n      context.fillStyle = 'rgba(128,128,128,0.05)';\n      context.beginPath();\n      context.moveTo(turtleState.location.x, turtleState.location.y);\n      context.lineTo(lidarRayTarget.x, lidarRayTarget.y);\n      context.stroke();\n      context.closePath();\n    }\n  }\n\n  context.save();\n  context.beginPath();\n  context.strokeStyle = 'black';\n  context.fillStyle = 'black';\n  context.moveTo(200, 50);\n  context.lineTo(200, 50 - 120);\n  context.translate(200, 50);\n  context.rotate(-Math.PI / 2);\n  context.textAlign = 'center';\n  context.font = \"8px Arial\";\n  context.fillText('Lidar distance', 60, -5);\n  context.stroke();\n  context.closePath();\n  context.restore();\n\n  const rateOfChanges1st = derivativeOf(currentFrame, currentRay, 1);\n  const rateOfChanges2nd = derivativeOf(rateOfChanges1st, currentRay, 1);\n\n  // Render derivatives\n  renderData(200, 90, 'DarkSlateGrey', rateOfChanges1st, maxNumScans, rotationOffset, 3, '1st derivative', 20);\n  renderData(200, 160, 'DarkSlateGrey', rateOfChanges2nd, maxNumScans, rotationOffset, 15, '2nd derivative',20);\n\n  const detectedFeatures = [];\n\n  // Check for maxima and sharp edges\n  for (let i = 0; i < currentRay; i++) {\n    const current1stValue = positionOverflowingValueFrom(i, rateOfChanges1st, maxNumScans);\n    const previous1stValue = positionOverflowingValueFrom(i - 1, rateOfChanges1st, maxNumScans);\n\n    const current2ndValue = positionOverflowingValueFrom(i, rateOfChanges2nd, maxNumScans);\n\n    var featureDetected = false;\n    if (current1stValue && previous1stValue && current2ndValue) {\n      if (previous1stValue >= 0 && current1stValue < 0) {\n        // Farest point, maxima in lidar data\n        featureDetected = true;\n      } else if (previous1stValue < 0 && current1stValue > 0.45) {\n        // Sharp edge\n        featureDetected = true;\n      }\n    }\n    const distance = currentFrame[i];\n    if (featureDetected && distance) {\n\n      const angle = angles[i];\n      const featureLocation = turtleState.location.polarProjection(angle, distance);\n\n      detectedFeatures.push({\n        angle: angle - turtleState.theta,\n        distance: distance,\n        uncertainty: Math.pow(5, 2)\n      });\n\n      // Mark Feature on the Map\n      context.beginPath();\n      context.strokeStyle = 'red';\n      context.fillStyle = 'red';\n      context.arc(featureLocation.x, featureLocation.y, 2, 0, 2 * Math.PI);\n      context.stroke();\n      context.closePath();\n\n      context.strokeStyle = 'lightgray';\n      context.fillStyle = 'lightgray';\n      context.beginPath();\n      context.moveTo(turtleState.location.x, turtleState.location.y);\n      context.lineTo(featureLocation.x, featureLocation.y);\n      context.stroke();\n      context.closePath();\n\n      // Mark Feature in Lidar data\n      let scanProfileX = 200 + ((i + rotationOffset) % maxNumScans);\n      let scanProfileYStart = 90;\n      let scanProfileYEnd = scanProfileYStart - rateOfChanges1st[i];\n\n      context.beginPath();\n      context.strokeStyle = 'red';\n      context.fillStyle = 'red';\n      context.arc(scanProfileX, scanProfileYEnd, 2, 0, 2 * Math.PI);\n      context.stroke();\n      context.closePath();\n\n      // Mark Feature in 1st derivative data\n      scanProfileX = 200 + ((i + rotationOffset) % maxNumScans);\n      scanProfileYStart = 50;\n      scanProfileYEnd = scanProfileYStart - currentFrame[i];\n\n      context.beginPath();\n      context.strokeStyle = 'red';\n      context.fillStyle = 'red';\n      context.arc(scanProfileX, scanProfileYEnd, 2, 0, 2 * Math.PI);\n      context.stroke();\n      context.closePath();\n    }\n  }\n\n  turtleMindModel.updateParticleState(detectedFeatures);\n}\n\nfunction callback() {\n  drawSimulation();\n  window.requestAnimationFrame(callback);\n}\n\nwindow.requestAnimationFrame(callback);\n\nwindow.addEventListener(\"keydown\", function(event) {\n  if (event.key === \"ArrowUp\") {\n\n    const dx = Math.cos(Math.PI / 180 * turtleState.theta) * 3;\n    const dy = Math.sin(Math.PI / 180 * turtleState.theta) * 3;\n\n    turtleState.location.translate(dx, dy);\n\n    turtleMindModel.moveTurtleBy(dx, dy)\n  }\n  if (event.key === \"ArrowDown\") {\n    const dx = Math.cos(Math.PI / 180 * turtleState.theta) * -3;\n    const dy =  Math.sin(Math.PI / 180 * turtleState.theta) * -3;\n\n    turtleState.location.translate(dx, dy);\n\n    turtleMindModel.moveTurtleBy(dx, dy)\n  }\n  if (event.key === \"ArrowLeft\") {\n    turtleState.theta -= 2;\n\n    turtleMindModel.rotateTurtle(-2);\n  }\n  if (event.key === \"ArrowRight\") {\n    turtleState.theta += 2;\n\n    turtleMindModel.rotateTurtle(2);\n  }\n});\n"]}