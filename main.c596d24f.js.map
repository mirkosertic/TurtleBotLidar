{"version":3,"sources":["js/main.js"],"names":["get_distance","x1","y1","x2","y2","noise","dx","dy","Math","sqrt","get_line_intersection","p0_x","p0_y","p1_x","p1_y","p2_x","p2_y","p3_x","p3_y","s1_x","s1_y","s2_x","s2_y","s","t","x","y","canvas","document","getElementById","context","getContext","walls","lineWidth","strokeStyle","fillStyle","scale","translate","turtleState","theta","lidarLength","lidarNoise","lidarMinResolution","turtleMindModel","estimatedTurtlePosition","features","moveTurtleBy","rotateTurtle","angle","noiseFilter","smoothing","enabled","currentValue","process","pos","newValue","gaussianNoise","value","u","v","random","num","log","cos","PI","positionOverflowingValueFrom","data","maxsize","derivativeOf","offset","result","i","leftPos","rightPos","polarLine","xp","yp","length","color","xTarget","yTarget","sin","beginPath","moveTo","lineTo","stroke","closePath","renderData","size","shiftOffset","scaleFactor","caption","height","dataPoint","drawXPosition","drawYPositionStart","drawYPositionEnd","save","rotate","textAlign","font","fillText","restore","drawSimulation","clearRect","wall","arc","currentRay","currentFrame","angles","rotationOffset","maxNumScans","rayTargetX","rayTargetY","nearestIntersection","undefined","j","intersection","distance","angleInRadians","wallX","wallY","scanProfileX","scanProfileYEnd","scanProfileYStart","rateOfChanges1st","rateOfChanges2nd","current1stValue","previous1stValue","current2ndValue","featureDetected","featureX","featureY","callback","window","requestAnimationFrame","addEventListener","event","key"],"mappings":"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","file":"main.c596d24f.js","sourceRoot":"..","sourcesContent":["function get_distance(x1, y1, x2, y2, noise) {\n  var dx = x2 - x1;\n  var dy = y2 - y1;\n  return Math.sqrt(dx *  dx + dy * dy) + noise;\n}\n\nfunction get_line_intersection(p0_x, p0_y, p1_x, p1_y, p2_x, p2_y, p3_x, p3_y)\n{\n  var s1_x, s1_y, s2_x, s2_y;\n  s1_x = p1_x - p0_x;\n  s1_y = p1_y - p0_y;\n  s2_x = p3_x - p2_x;\n  s2_y = p3_y - p2_y;\n\n  var s, t;\n  s = (-s1_y * (p0_x - p2_x) + s1_x * (p0_y - p2_y)) / (-s2_x * s1_y + s1_x * s2_y);\n  t = ( s2_x * (p0_y - p2_y) - s2_y * (p0_x - p2_x)) / (-s2_x * s1_y + s1_x * s2_y);\n\n  if (s >= 0 && s <= 1 && t >= 0 && t <= 1)\n  {\n    return {\n      x: p0_x + (t * s1_x),\n      y: p0_y + (t * s1_y)\n    }\n  }\n\n  return undefined;\n}\n\nvar canvas = document.getElementById(\"rendering\");\nvar context = canvas.getContext(\"2d\");\n\nvar walls = [\n  {\n    x1: 0,\n    y1: 0,\n    x2: 150,\n    y2 : 0\n  },\n  {\n    x1: 150,\n    y1: 0,\n    x2: 150,\n    y2 : 100\n  },\n  {\n    x1: 150,\n    y1: 100,\n    x2: 0,\n    y2 : 100\n  },\n  {\n    x1: 0,\n    y1: 0,\n    x2: 0,\n    y2 : 100\n  },\n  {\n    x1: 150,\n    y1: 80,\n    x2: 130,\n    y2 : 80\n  },\n  {\n    x1: 130,\n    y1: 100,\n    x2: 130,\n    y2 : 80\n  },\n];\n\ncontext.lineWidth = 1;\ncontext.strokeStyle = 'black';\ncontext.fillStyle = 'black';\ncontext.scale(2, 2);\ncontext.translate(100, 100);\n\nvar turtleState = {\n  x: 56,\n  y: 56,\n  theta: 0,\n  lidarLength: 100,\n  lidarNoise: 0,\n  lidarMinResolution: 1,\n}\n\nvar turtleMindModel = {\n  estimatedTurtlePosition: {x: 0, y:0, theta: 0},\n  features: [],\n  moveTurtleBy: function(dx, dy) {\n    this.estimatedTurtlePosition.x += dx;\n    this.estimatedTurtlePosition.y += dy;\n  },\n  rotateTurtle: function(angle) {\n    this.estimatedTurtlePosition.theta += angle;\n  },\n};\n\nvar noiseFilter = {\n  smoothing : 2.5,\n  enabled: false,\n  currentValue: [],\n  process: function(pos, newValue) {\n    if (this.enabled) {\n      if (this.currentValue[pos]) {\n        this.currentValue[pos] += (newValue - this.currentValue[pos]) / this.smoothing;\n        return this.currentValue[pos];\n      } else {\n        this.currentValue[pos] = newValue;\n        return newValue;\n      }\n    } else {\n      return newValue;\n    }\n  }\n}\n\nfunction gaussianNoise(value) {\n  //return (((Math.random() + Math.random() + Math.random() + Math.random()) / 4) - 0.5) * value;\n  let u = 0, v = 0;\n  while(u === 0) u = Math.random(); //Converting [0,1) to (0,1)\n  while(v === 0) v = Math.random();\n  let num = Math.sqrt( -2.0 * Math.log( u ) ) * Math.cos( 2.0 * Math.PI * v );\n  num = num / 10.0 + 0.5; // Translate to 0 -> 1\n  if (num > 1 || num < 0) return gaussianNoise() // resample between 0 and 1\n  return (num - 0.5) * value\n}\n\nfunction positionOverflowingValueFrom(pos, data, maxsize) {\n  if (pos < 0) {\n    pos += maxsize;\n  } else if (pos >= maxsize) {\n    pos -= maxsize;\n  }\n  return data[pos];\n}\n\nvar derivativeOf = function(data,maxsize,offset) {\n  var result = []\n  for (var i = 0; i < maxsize; i++) {\n    var leftPos = positionOverflowingValueFrom(i, data, maxsize);\n    var rightPos = positionOverflowingValueFrom(i + offset, data, maxsize);\n    if (leftPos && rightPos) {\n      result[i] = (rightPos - leftPos);\n    }\n  }\n  return result;\n}\n\nvar polarLine = function(xp, yp, angle, length, color) {\n  var xTarget = xp + Math.cos(Math.PI / 180 * angle) * length;\n  var yTarget = yp + Math.sin(Math.PI / 180 * angle) * length;\n  context.strokeStyle = color;\n  context.fillStyle = color;\n  context.beginPath();\n  context.moveTo(xp, yp);\n  context.lineTo(xTarget, yTarget);\n  context.stroke();\n  context.closePath();\n}\n\nvar renderData = function(xp, yp, color, data, size, shiftOffset, scaleFactor, caption, height) {\n\n  for (var i = 0; i < size; i++) {\n\n    var dataPoint = data[i];\n    if (dataPoint) {\n\n      var drawXPosition = xp + ((i + shiftOffset) % size);\n      var drawYPositionStart = yp;\n      var drawYPositionEnd = drawYPositionStart + dataPoint * scaleFactor;\n\n      context.beginPath();\n      context.strokeStyle = color;\n      context.fillStyle = color;\n\n      context.moveTo(drawXPosition, drawYPositionStart);\n      context.lineTo(drawXPosition, drawYPositionEnd);\n\n      context.stroke();\n      context.closePath();\n    }\n  }\n\n  context.save();\n\n  context.beginPath();\n  context.strokeStyle = 'black';\n  context.fillStyle = 'black';\n\n  context.moveTo(xp, yp - height);\n  context.lineTo(xp, yp + height);\n\n  context.translate(xp, yp);\n  context.rotate(-Math.PI / 2);\n  context.textAlign = 'center';\n  context.font = \"8px Arial\";\n  context.fillText(caption, 0, -5);\n\n  context.stroke();\n  context.closePath();\n\n  context.restore();\n}\n\nvar drawSimulation = function() {\n\n  context.clearRect(-100, -100, 1000, 1000);\n\n  // Render reality\n  context.strokeStyle = 'black';\n  context.fillStyle = 'black';\n  context.textAlign = 'left';\n  context.font = \"8px Arial\";\n  context.fillText('Reality', -20, -20);\n\n  // Draw the walls\n  context.strokeStyle = 'black';\n  context.fillStyle = 'black';\n  context.beginPath();\n  for (i = 0; i < walls.length; i++) {\n    var wall = walls[i];\n    context.moveTo(wall.x1, wall.y1);\n    context.lineTo(wall.x2, wall.y2);\n  }\n  context.stroke();\n  context.closePath();\n\n  // Draw the turtle\n  context.beginPath();\n  context.strokeStyle = 'gray';\n  context.fillStyle = 'gray';\n  context.arc(turtleState.x, turtleState.y, 8, 0, 2 * Math.PI);\n  context.stroke();\n  context.closePath();\n\n  polarLine(turtleState.x, turtleState.y, turtleState.theta, 20, 'green');\n\n  // Render turtles model\n  context.strokeStyle = 'black';\n  context.fillStyle = 'black';\n  context.textAlign = 'left';\n  context.font = \"8px Arial\";\n  context.fillText('Turtles model', -20, 120);\n\n  context.beginPath();\n  context.strokeStyle = 'gray';\n  context.fillStyle = 'gray';\n  context.arc(turtleMindModel.estimatedTurtlePosition.x + 56, turtleMindModel.estimatedTurtlePosition.y + 200, 8, 0, 2 * Math.PI);\n  context.stroke();\n  context.closePath();\n\n  polarLine(turtleMindModel.estimatedTurtlePosition.x + 56, turtleMindModel.estimatedTurtlePosition.y + 200, turtleMindModel.estimatedTurtlePosition.theta, 20, 'green');\n\n  var currentRay = 0;\n  var currentFrame = [];\n  var angles = [];\n\n  var maxNumScans = 360 / turtleState.lidarMinResolution;\n  var rotationOffset = maxNumScans / 2;\n\n  for (var i = turtleState.theta; i < turtleState.theta + 360; i += turtleState.lidarMinResolution, currentRay++) {\n    var rayTargetX = turtleState.x + Math.cos(Math.PI / 180 * i) * turtleState.lidarLength;\n    var rayTargetY = turtleState.y + Math.sin(Math.PI / 180 * i) * turtleState.lidarLength;\n\n    var nearestIntersection = undefined;\n    for (var j = 0; j < walls.length; j++) {\n      var wall = walls[j];\n\n      var intersection = get_line_intersection(turtleState.x, turtleState.y, rayTargetX, rayTargetY, wall.x1, wall.y1, wall.x2, wall.y2);\n      if (intersection) {\n        var distance = noiseFilter.process(currentRay, get_distance(turtleState.x, turtleState.y, intersection.x, intersection.y, gaussianNoise(turtleState.lidarNoise)));\n        if (nearestIntersection) {\n          if (nearestIntersection.distance > distance) {\n            nearestIntersection = {\n              distance: distance,\n              intersection: intersection\n            };\n          }\n        } else {\n          nearestIntersection = {\n            distance: distance,\n            intersection: intersection\n          }\n        }\n      }\n    }\n\n    if (nearestIntersection) {\n\n      currentFrame[currentRay] = nearestIntersection.distance;\n      angles[currentRay] = i;\n\n      // Do some back projection\n      var angleInRadians = Math.PI / 180 * i;\n      var wallX = turtleState.x + Math.cos(angleInRadians) * nearestIntersection.distance;\n      var wallY = turtleState.y + Math.sin(angleInRadians) * nearestIntersection.distance;\n\n      context.beginPath();\n      context.strokeStyle = 'CadetBlue';\n      context.fillStyle = 'CadetBlue';\n      context.arc(wallX, wallY, 2, 0, 2 * Math.PI);\n      context.stroke();\n      context.closePath();\n\n      context.beginPath();\n      if (currentRay === 0) {\n        context.strokeStyle = 'green';\n        context.fillStyle = 'green';\n      } else {\n        context.strokeStyle = 'CadetBlue';\n        context.fillStyle = 'CadetBlue';\n      }\n\n      var scanProfileX = 200 + ((currentRay + rotationOffset) % maxNumScans);\n      var scanProfileYStart = 50;\n      var scanProfileYEnd = scanProfileYStart - nearestIntersection.distance;\n\n      context.moveTo(scanProfileX, scanProfileYStart);\n      context.lineTo(scanProfileX, scanProfileYEnd);\n\n      context.stroke();\n      context.closePath();\n\n    } else {\n      context.strokeStyle = 'rgba(128,128,128,0.05)';\n      context.fillStyle = 'rgba(128,128,128,0.05)';\n      context.beginPath();\n      context.moveTo(turtleState.x, turtleState.y);\n      context.lineTo(rayTargetX, rayTargetY);\n      context.stroke();\n      context.closePath();\n    }\n  }\n\n  context.save();\n  context.beginPath();\n  context.strokeStyle = 'black';\n  context.fillStyle = 'black';\n  context.moveTo(200, 50);\n  context.lineTo(200, 50 - 120);\n  context.translate(200, 50);\n  context.rotate(-Math.PI / 2);\n  context.textAlign = 'center';\n  context.font = \"8px Arial\";\n  context.fillText('Lidar distance', 60, -5);\n  context.stroke();\n  context.closePath();\n  context.restore();\n\n  var rateOfChanges1st = derivativeOf(currentFrame, currentRay, 1);\n  var rateOfChanges2nd = derivativeOf(rateOfChanges1st, currentRay, 1);\n\n  var maxNumScans = 360 / turtleState.lidarMinResolution;\n  var rotationOffset = maxNumScans / 2;\n\n  // Render derivatives\n  renderData(200, 90, 'DarkSlateGrey', rateOfChanges1st, maxNumScans, rotationOffset, 3, '1st derivative', 20);\n  renderData(200, 160, 'DarkSlateGrey', rateOfChanges2nd, maxNumScans, rotationOffset, 15, '2nd derivative',20);\n\n  // Check for maxima and sharp edges\n  for (var i = 0; i < currentRay; i++) {\n    var current1stValue = positionOverflowingValueFrom(i, rateOfChanges1st, maxNumScans);\n    var previous1stValue = positionOverflowingValueFrom(i - 1, rateOfChanges1st, maxNumScans);\n\n    var current2ndValue = positionOverflowingValueFrom(i, rateOfChanges2nd, maxNumScans);\n\n    var featureDetected = false;\n    if (current1stValue && previous1stValue && current2ndValue) {\n      if (previous1stValue >= 0 && current1stValue < 0) {\n        // Farest point, maxima in lidar data\n        featureDetected = true;\n      } else if (previous1stValue < 0 && current1stValue > 0.025) {\n        // Sharp edge\n        featureDetected = true;\n      }\n    }\n    var distance = currentFrame[i];\n    if (featureDetected && distance) {\n\n      var angle = angles[i];\n      var angleInRadians = Math.PI / 180 * angle;\n      var featureX = turtleState.x + Math.cos(angleInRadians) * distance;\n      var featureY = turtleState.y + Math.sin(angleInRadians) * distance;\n\n      // Mark Feature on the Map\n      context.beginPath();\n      context.strokeStyle = 'red';\n      context.fillStyle = 'red';\n      context.arc(featureX, featureY, 2, 0, 2 * Math.PI);\n      context.stroke();\n      context.closePath();\n\n      context.strokeStyle = 'lightgray';\n      context.fillStyle = 'lightgray';\n      context.beginPath();\n      context.moveTo(turtleState.x, turtleState.y);\n      context.lineTo(featureX, featureY);\n      context.stroke();\n      context.closePath();\n\n      // Mark Feature in Lidar data\n      var maxNumScans = 360 / turtleState.lidarMinResolution;\n      var rotationOffset = maxNumScans / 2;\n\n      var scanProfileX = 200 + ((i + rotationOffset) % maxNumScans);\n      var scanProfileYStart = 90;\n      var scanProfileYEnd = scanProfileYStart - rateOfChanges1st[i];\n\n      context.beginPath();\n      context.strokeStyle = 'red';\n      context.fillStyle = 'red';\n      context.arc(scanProfileX, scanProfileYEnd, 2, 0, 2 * Math.PI);\n      context.stroke();\n      context.closePath();\n\n      // Mark Feature in 1st derivative data\n      var scanProfileX = 200 + ((i + rotationOffset) % maxNumScans);\n      var scanProfileYStart = 50;\n      var scanProfileYEnd = scanProfileYStart - currentFrame[i];\n\n      context.beginPath();\n      context.strokeStyle = 'red';\n      context.fillStyle = 'red';\n      context.arc(scanProfileX, scanProfileYEnd, 2, 0, 2 * Math.PI);\n      context.stroke();\n      context.closePath();\n    }\n  }\n}\n\nvar callback = function() {\n  drawSimulation();\n  window.requestAnimationFrame(callback);\n}\n\nwindow.requestAnimationFrame(callback);\n\nwindow.addEventListener(\"keydown\", function(event) {\n  if (event.key == \"ArrowUp\") {\n\n    var dx = Math.cos(Math.PI / 180 * turtleState.theta) * 3;\n    var dy = Math.sin(Math.PI / 180 * turtleState.theta) * 3;\n\n    turtleState.x += dx;\n    turtleState.y += dy;\n\n    turtleMindModel.moveTurtleBy(dx, dy)\n  }\n  if (event.key == \"ArrowDown\") {\n    var dx = Math.cos(Math.PI / 180 * turtleState.theta) * -3;\n    var dy =  Math.sin(Math.PI / 180 * turtleState.theta) * -3;\n\n    turtleState.x += dx;\n    turtleState.y += dy;\n\n    turtleMindModel.moveTurtleBy(dx, dy)\n  }\n  if (event.key == \"ArrowLeft\") {\n    turtleState.theta -= 2;\n\n    turtleMindModel.rotateTurtle(-2);\n  }\n  if (event.key == \"ArrowRight\") {\n    turtleState.theta += 2;\n\n    turtleMindModel.rotateTurtle(2);\n  }\n});\n\n"]}