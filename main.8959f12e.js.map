{"version":3,"sources":["js/main.js"],"names":["get_distance","x1","y1","x2","y2","noise","dx","dy","Math","sqrt","get_line_intersection","p0_x","p0_y","p1_x","p1_y","p2_x","p2_y","p3_x","p3_y","s1_x","s1_y","s2_x","s2_y","s","t","x","y","canvas","document","getElementById","context","getContext","walls","lineWidth","strokeStyle","fillStyle","scale","translate","turtleState","theta","lidarLength","lidarNoise","lidarMinResolution","noiseFilter","smoothing","enabled","currentValue","process","pos","newValue","gaussianNoise","value","u","v","random","num","log","cos","PI","positionOverflowingValueFrom","data","maxsize","derivativeOf","offset","result","i","leftPos","rightPos","renderData","xp","yp","color","size","shiftOffset","scaleFactor","caption","height","dataPoint","drawXPosition","drawYPositionStart","drawYPositionEnd","beginPath","moveTo","lineTo","stroke","closePath","save","rotate","textAlign","font","fillText","restore","drawSimulation","clearRect","length","wall","arc","lockingAtX","lockingAtY","sin","currentRay","currentFrame","angles","rotationOffset","maxNumScans","rayTargetX","rayTargetY","nearestIntersection","undefined","j","intersection","distance","angleInRadians","wallX","wallY","scanProfileX","scanProfileYEnd","scanProfileYStart","rateOfChanges1st","rateOfChanges2nd","current1stValue","previous1stValue","current2ndValue","featureDetected","angle","featureX","featureY","callback","window","requestAnimationFrame","addEventListener","event","key"],"mappings":"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","file":"main.8959f12e.js","sourceRoot":"..","sourcesContent":["function get_distance(x1, y1, x2, y2, noise) {\n  var dx = x2 - x1;\n  var dy = y2 - y1;\n  return Math.sqrt(dx *  dx + dy * dy) + noise;\n}\n\nfunction get_line_intersection(p0_x, p0_y, p1_x, p1_y, p2_x, p2_y, p3_x, p3_y)\n{\n  var s1_x, s1_y, s2_x, s2_y;\n  s1_x = p1_x - p0_x;\n  s1_y = p1_y - p0_y;\n  s2_x = p3_x - p2_x;\n  s2_y = p3_y - p2_y;\n\n  var s, t;\n  s = (-s1_y * (p0_x - p2_x) + s1_x * (p0_y - p2_y)) / (-s2_x * s1_y + s1_x * s2_y);\n  t = ( s2_x * (p0_y - p2_y) - s2_y * (p0_x - p2_x)) / (-s2_x * s1_y + s1_x * s2_y);\n\n  if (s >= 0 && s <= 1 && t >= 0 && t <= 1)\n  {\n    return {\n      x: p0_x + (t * s1_x),\n      y: p0_y + (t * s1_y)\n    }\n  }\n\n  return undefined;\n}\n\nvar canvas = document.getElementById(\"rendering\");\nvar context = canvas.getContext(\"2d\");\n\nvar walls = [\n  {\n    x1: 0,\n    y1: 0,\n    x2: 150,\n    y2 : 0\n  },\n  {\n    x1: 150,\n    y1: 0,\n    x2: 150,\n    y2 : 100\n  },\n  {\n    x1: 150,\n    y1: 100,\n    x2: 0,\n    y2 : 100\n  },\n  {\n    x1: 0,\n    y1: 0,\n    x2: 0,\n    y2 : 100\n  },\n  {\n    x1: 150,\n    y1: 80,\n    x2: 130,\n    y2 : 80\n  },\n  {\n    x1: 130,\n    y1: 100,\n    x2: 130,\n    y2 : 80\n  },\n];\n\ncontext.lineWidth = 1;\ncontext.strokeStyle = 'black';\ncontext.fillStyle = 'black';\ncontext.scale(2, 2);\ncontext.translate(100, 100);\n\nvar turtleState = {\n  x: 56,\n  y: 56,\n  theta: 0,\n  lidarLength: 100,\n  lidarNoise: 0,\n  lidarMinResolution: 1\n}\n\nvar noiseFilter = {\n  smoothing : 2.5,\n  enabled: false,\n  currentValue: [],\n  process: function(pos, newValue) {\n    if (this.enabled) {\n      if (this.currentValue[pos]) {\n        this.currentValue[pos] += (newValue - this.currentValue[pos]) / this.smoothing;\n        return this.currentValue[pos];\n      } else {\n        this.currentValue[pos] = newValue;\n        return newValue;\n      }\n    } else {\n      return newValue;\n    }\n  }\n}\n\nfunction gaussianNoise(value) {\n  //return (((Math.random() + Math.random() + Math.random() + Math.random()) / 4) - 0.5) * value;\n  let u = 0, v = 0;\n  while(u === 0) u = Math.random(); //Converting [0,1) to (0,1)\n  while(v === 0) v = Math.random();\n  let num = Math.sqrt( -2.0 * Math.log( u ) ) * Math.cos( 2.0 * Math.PI * v );\n  num = num / 10.0 + 0.5; // Translate to 0 -> 1\n  if (num > 1 || num < 0) return gaussianNoise() // resample between 0 and 1\n  return (num - 0.5) * value\n}\n\nfunction positionOverflowingValueFrom(pos, data, maxsize) {\n  if (pos < 0) {\n    pos += maxsize;\n  } else if (pos >= maxsize) {\n    pos -= maxsize;\n  }\n  return data[pos];\n}\n\nvar derivativeOf = function(data,maxsize,offset) {\n  var result = []\n  for (var i = 0; i < maxsize; i++) {\n    var leftPos = positionOverflowingValueFrom(i, data, maxsize);\n    var rightPos = positionOverflowingValueFrom(i + offset, data, maxsize);\n    if (leftPos && rightPos) {\n      result[i] = (rightPos - leftPos);\n    }\n  }\n  return result;\n}\n\nvar renderData = function(xp, yp, color, data, size, shiftOffset, scaleFactor, caption, height) {\n\n  for (var i = 0; i < size; i++) {\n\n    var dataPoint = data[i];\n    if (dataPoint) {\n\n      var drawXPosition = xp + ((i + shiftOffset) % size);\n      var drawYPositionStart = yp;\n      var drawYPositionEnd = drawYPositionStart + dataPoint * scaleFactor;\n\n      context.beginPath();\n      context.strokeStyle = color;\n      context.fillStyle = color;\n\n      context.moveTo(drawXPosition, drawYPositionStart);\n      context.lineTo(drawXPosition, drawYPositionEnd);\n\n      context.stroke();\n      context.closePath();\n    }\n  }\n\n  context.save();\n\n  context.beginPath();\n  context.strokeStyle = 'black';\n  context.fillStyle = 'black';\n\n  context.moveTo(xp, yp - height);\n  context.lineTo(xp, yp + height);\n\n  context.translate(xp, yp);\n  context.rotate(-Math.PI / 2);\n  context.textAlign = 'center';\n  context.font = \"8px Arial\";\n  context.fillText(caption, 0, -5);\n\n  context.stroke();\n  context.closePath();\n\n  context.restore();\n}\n\nvar drawSimulation = function() {\n\n  context.clearRect(-100, -100, 1000, 1000);\n\n  // Draw the walls\n  context.strokeStyle = 'black';\n  context.fillStyle = 'black';\n  context.beginPath();\n  for (i = 0; i < walls.length; i++) {\n    var wall = walls[i];\n    context.moveTo(wall.x1, wall.y1);\n    context.lineTo(wall.x2, wall.y2);\n  }\n  context.stroke();\n  context.closePath();\n\n  // Draw the turtle\n  context.beginPath();\n  context.strokeStyle = 'gray';\n  context.fillStyle = 'gray';\n  context.arc(turtleState.x, turtleState.y, 8, 0, 2 * Math.PI);\n  context.stroke();\n  context.closePath();\n\n  var lockingAtX = turtleState.x + Math.cos(Math.PI / 180 * turtleState.theta) * 20;\n  var lockingAtY = turtleState.y + Math.sin(Math.PI / 180 * turtleState.theta) * 20;\n  context.strokeStyle = 'green';\n  context.fillStyle = 'green';\n  context.beginPath();\n  context.moveTo(turtleState.x, turtleState.y);\n  context.lineTo(lockingAtX, lockingAtY);\n  context.stroke();\n  context.closePath();\n\n  var currentRay = 0;\n  var currentFrame = [];\n  var angles = [];\n\n  var maxNumScans = 360 / turtleState.lidarMinResolution;\n  var rotationOffset = maxNumScans / 2;\n\n  for (var i = turtleState.theta; i < turtleState.theta + 360; i += turtleState.lidarMinResolution, currentRay++) {\n    var rayTargetX = turtleState.x + Math.cos(Math.PI / 180 * i) * turtleState.lidarLength;\n    var rayTargetY = turtleState.y + Math.sin(Math.PI / 180 * i) * turtleState.lidarLength;\n\n    var nearestIntersection = undefined;\n    for (var j = 0; j < walls.length; j++) {\n      var wall = walls[j];\n\n      var intersection = get_line_intersection(turtleState.x, turtleState.y, rayTargetX, rayTargetY, wall.x1, wall.y1, wall.x2, wall.y2);\n      if (intersection) {\n        var distance = noiseFilter.process(currentRay, get_distance(turtleState.x, turtleState.y, intersection.x, intersection.y, gaussianNoise(turtleState.lidarNoise)));\n        if (nearestIntersection) {\n          if (nearestIntersection.distance > distance) {\n            nearestIntersection = {\n              distance: distance,\n              intersection: intersection\n            };\n          }\n        } else {\n          nearestIntersection = {\n            distance: distance,\n            intersection: intersection\n          }\n        }\n      }\n    }\n\n    if (nearestIntersection) {\n\n      currentFrame[currentRay] = nearestIntersection.distance;\n      angles[currentRay] = i;\n\n      // Do some back projection\n      var angleInRadians = Math.PI / 180 * i;\n      var wallX = turtleState.x + Math.cos(angleInRadians) * nearestIntersection.distance;\n      var wallY = turtleState.y + Math.sin(angleInRadians) * nearestIntersection.distance;\n\n      context.beginPath();\n      context.strokeStyle = 'CadetBlue';\n      context.fillStyle = 'CadetBlue';\n      context.arc(wallX, wallY, 2, 0, 2 * Math.PI);\n      context.stroke();\n      context.closePath();\n\n      context.beginPath();\n      if (currentRay === 0) {\n        context.strokeStyle = 'green';\n        context.fillStyle = 'green';\n      } else {\n        context.strokeStyle = 'CadetBlue';\n        context.fillStyle = 'CadetBlue';\n      }\n\n      var scanProfileX = 200 + ((currentRay + rotationOffset) % maxNumScans);\n      var scanProfileYStart = 50;\n      var scanProfileYEnd = scanProfileYStart - nearestIntersection.distance;\n\n      context.moveTo(scanProfileX, scanProfileYStart);\n      context.lineTo(scanProfileX, scanProfileYEnd);\n\n      context.stroke();\n      context.closePath();\n\n    } else {\n      context.strokeStyle = 'rgba(128,128,128,0.05)';\n      context.fillStyle = 'rgba(128,128,128,0.05)';\n      context.beginPath();\n      context.moveTo(turtleState.x, turtleState.y);\n      context.lineTo(rayTargetX, rayTargetY);\n      context.stroke();\n      context.closePath();\n    }\n  }\n\n  context.save();\n  context.beginPath();\n  context.strokeStyle = 'black';\n  context.fillStyle = 'black';\n  context.moveTo(200, 50);\n  context.lineTo(200, 50 - 120);\n  context.translate(200, 50);\n  context.rotate(-Math.PI / 2);\n  context.textAlign = 'center';\n  context.font = \"8px Arial\";\n  context.fillText('Lidar distance', 60, -5);\n  context.stroke();\n  context.closePath();\n  context.restore();\n\n  var rateOfChanges1st = derivativeOf(currentFrame, currentRay, 1);\n  var rateOfChanges2nd = derivativeOf(rateOfChanges1st, currentRay, 1);\n\n  var maxNumScans = 360 / turtleState.lidarMinResolution;\n  var rotationOffset = maxNumScans / 2;\n\n  // Render derivatives\n  renderData(200, 90, 'DarkSlateGrey', rateOfChanges1st, maxNumScans, rotationOffset, 3, '1st derivative', 20);\n  renderData(200, 160, 'DarkSlateGrey', rateOfChanges2nd, maxNumScans, rotationOffset, 15, '2nd derivative',20);\n\n  // Check for maxima and sharp edges\n  for (var i = 0; i < currentRay; i++) {\n    var current1stValue = positionOverflowingValueFrom(i, rateOfChanges1st, maxNumScans);\n    var previous1stValue = positionOverflowingValueFrom(i - 1, rateOfChanges1st, maxNumScans);\n\n    var current2ndValue = positionOverflowingValueFrom(i, rateOfChanges2nd, maxNumScans);\n\n    var featureDetected = false;\n    if (current1stValue && previous1stValue && current2ndValue) {\n      if (previous1stValue >= 0 && current1stValue < 0) {\n        // Farest point, maxima in lidar data\n        featureDetected = true;\n      } else if (previous1stValue < 0 && current1stValue > 0.025) {\n        // Sharp edge\n        featureDetected = true;\n      }\n    }\n    var distance = currentFrame[i];\n    if (featureDetected && distance) {\n\n      var angle = angles[i];\n      var angleInRadians = Math.PI / 180 * angle;\n      var featureX = turtleState.x + Math.cos(angleInRadians) * distance;\n      var featureY = turtleState.y + Math.sin(angleInRadians) * distance;\n\n      // Mark Feature on the Map\n      context.beginPath();\n      context.strokeStyle = 'red';\n      context.fillStyle = 'red';\n      context.arc(featureX, featureY, 2, 0, 2 * Math.PI);\n      context.stroke();\n      context.closePath();\n\n      context.strokeStyle = 'lightgray';\n      context.fillStyle = 'lightgray';\n      context.beginPath();\n      context.moveTo(turtleState.x, turtleState.y);\n      context.lineTo(featureX, featureY);\n      context.stroke();\n      context.closePath();\n\n      // Mark Feature in Lidar data\n      var maxNumScans = 360 / turtleState.lidarMinResolution;\n      var rotationOffset = maxNumScans / 2;\n\n      var scanProfileX = 200 + ((i + rotationOffset) % maxNumScans);\n      var scanProfileYStart = 90;\n      var scanProfileYEnd = scanProfileYStart - rateOfChanges1st[i];\n\n      context.beginPath();\n      context.strokeStyle = 'red';\n      context.fillStyle = 'red';\n      context.arc(scanProfileX, scanProfileYEnd, 2, 0, 2 * Math.PI);\n      context.stroke();\n      context.closePath();\n\n      // Mark Feature in 1st derivative data\n      var scanProfileX = 200 + ((i + rotationOffset) % maxNumScans);\n      var scanProfileYStart = 50;\n      var scanProfileYEnd = scanProfileYStart - currentFrame[i];\n\n      context.beginPath();\n      context.strokeStyle = 'red';\n      context.fillStyle = 'red';\n      context.arc(scanProfileX, scanProfileYEnd, 2, 0, 2 * Math.PI);\n      context.stroke();\n      context.closePath();\n    }\n  }\n}\n\nvar callback = function() {\n  drawSimulation();\n  window.requestAnimationFrame(callback);\n}\n\nwindow.requestAnimationFrame(callback);\n\nwindow.addEventListener(\"keydown\", function(event) {\n  if (event.key == \"ArrowUp\") {\n    turtleState.x += Math.cos(Math.PI / 180 * turtleState.theta) * 3;\n    turtleState.y += Math.sin(Math.PI / 180 * turtleState.theta) * 3;\n  }\n  if (event.key == \"ArrowDown\") {\n    turtleState.x += Math.cos(Math.PI / 180 * turtleState.theta) * -3;\n    turtleState.y += Math.sin(Math.PI / 180 * turtleState.theta) * -3;\n  }\n  if (event.key == \"ArrowLeft\") {\n    turtleState.theta -= 2;\n  }\n  if (event.key == \"ArrowRight\") {\n    turtleState.theta += 2;\n  }\n});\n\n"]}