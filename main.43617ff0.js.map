{"version":3,"sources":["js/geom.js","js/noise.js","js/envsim.js","js/derivative.js","js/main.js"],"names":["Point","x","y","anotherPoint","dx","dy","Math","sqrt","angle","distance","angleInRadians","PI","cos","sin","mx","my","Linesegment","a","b","otherLineSegment","s1_x","s1_y","s2_x","s2_y","s","t","gaussianNoise","value","u","v","random","num","log","TurtleState","location","theta","lidarLength","lidarNoise","lidarSamples","lidarMinResolution","edgeDetectionThreshold","walls","distances","angles","currentRay","i","lidarRayTarget","polarProjection","nearestIntersection","undefined","j","length","wall","intersection","intersectionWith","distanceTo","k","positionOverflowingValueFrom","pos","data","maxsize","derivativeOfInternal","offset","leftPos","rightPos","derivativeOf","result","sum","samples","res","canvas","document","getElementById","context","getContext","lineWidth","strokeStyle","fillStyle","scale","translate","turtleState","turtleMindModel","particles","score","uncertainty","pow","estimatedState","particle","features","featureDetectionRadius","moveTurtleBy","newParticles","concat","rotateTurtle","updateParticleState","detectedFeatures","feature","push","expectedFeature","detectedFeature","measuredFeaturePosition","beginPath","arc","stroke","closePath","identified","distanceToFeature","kg","updatedNewDistance","oldLocation","meanScore","filter","index","arr","console","polarLine","color","rayTarget","moveTo","lineTo","renderData","xp","yp","size","shiftOffset","scaleFactor","caption","height","dataPoint","drawXPosition","drawYPositionStart","drawYPositionEnd","save","rotate","textAlign","font","fillText","restore","dataBlob","drawSimulation","clearRect","toPrecision","lidarFrame","currentFrame","maxNumScans","rotationOffset","wallHitPoint","scanProfileX","scanProfileYEnd","rateOfChanges1st","rateOfChanges2nd","csv","current1stValue","next1stValue","current2ndValue","featureDetected","abs","round","featureLocation","scanProfileYStart","Blob","type","element","href","window","URL","createObjectURL","dowload","callback","requestAnimationFrame","addEventListener","event","key"],"mappings":"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","file":"main.43617ff0.js","sourceRoot":"..","sourcesContent":["/**\n * A simple point.\n */\nclass Point {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  distanceTo(anotherPoint) {\n    const dx = anotherPoint.x - this.x;\n    const dy = anotherPoint.y - this.y;\n    return Math.sqrt(dx * dx + dy * dy);\n  }\n\n  polarProjection(angle, distance) {\n    const angleInRadians = Math.PI / 180 * angle;\n    return new Point(this.x + Math.cos(angleInRadians) * distance, this.y + Math.sin(angleInRadians) * distance);\n  }\n\n  translate(mx, my) {\n    this.x += mx;\n    this.y += my;\n    return this;\n  }\n}\n\n/**\n * A line is a connection between two points.\n */\nclass Linesegment {\n  constructor(a, b) {\n    this.a = a;\n    this.b = b;\n  }\n\n  intersectionWith(otherLineSegment) {\n    const s1_x = this.b.x - this.a.x;\n    const s1_y = this.b.y - this.a.y;\n    const s2_x = otherLineSegment.b.x - otherLineSegment.a.x;\n    const s2_y = otherLineSegment.b.y - otherLineSegment.a.y;\n\n    const s = (-s1_y * (this.a.x - otherLineSegment.a.x) + s1_x * (this.a.y - otherLineSegment.a.y)) / (-s2_x * s1_y + s1_x * s2_y);\n    const t = ( s2_x * (this.a.y - otherLineSegment.a.y) - s2_y * (this.a.x - otherLineSegment.a.x)) / (-s2_x * s1_y + s1_x * s2_y);\n\n    if (s >= 0 && s <= 1 && t >= 0 && t <= 1) {\n      return new Point(this.a.x + (t * s1_x), this.a.y + (t * s1_y));\n    }\n\n    return undefined;\n  }\n}\n\nexport {Point, Linesegment};\n","function gaussianNoise(value) {\n  //return (((Math.random() + Math.random() + Math.random() + Math.random()) / 4) - 0.5) * value;\n  let u = 0, v = 0;\n  while(u === 0) u = Math.random(); //Converting [0,1) to (0,1)\n  while(v === 0) v = Math.random();\n  let num = Math.sqrt( -2.0 * Math.log( u ) ) * Math.cos( 2.0 * Math.PI * v );\n  num = num / 10.0 + 0.5; // Translate to 0 -> 1\n  if (num > 1 || num < 0) return gaussianNoise() // resample between 0 and 1\n  return (num - 0.5) * value\n}\n\nexport {gaussianNoise}\n","import {Linesegment, Point} from \"./geom.js\"\nimport {gaussianNoise} from \"./noise\";\n\nclass TurtleState {\n\n  constructor() {\n    this.location = new Point(56, 56);\n    this.theta = 45;\n    this.lidarLength = 100;\n    this.lidarNoise = 0;\n    this.lidarSamples = 0;\n    this.lidarMinResolution = 1;\n    this.edgeDetectionThreshold = 5;\n    this.walls = [\n      new Linesegment(new Point(0,0), new Point(150, 0)),\n      new Linesegment(new Point(150, 0), new Point(150, 100)),\n      new Linesegment(new Point(150, 100), new Point(0, 100)),\n      new Linesegment(new Point(0, 0), new Point(0, 100)),\n      new Linesegment(new Point(150, 80), new Point(130, 80)),\n      new Linesegment(new Point(130, 100), new Point(130, 80))\n    ];\n  }\n\n  lidarFrame() {\n    const distances = [];\n    const angles = [];\n\n    let currentRay = 0;\n    for (let i = this.theta; i < this.theta + 360; i += this.lidarMinResolution, currentRay++) {\n      angles[currentRay] = i;\n\n      const lidarRayTarget = this.location.polarProjection(i, this.lidarLength);\n\n      var nearestIntersection = undefined;\n      for (let j = 0; j < this.walls.length; j++) {\n        const wall = this.walls[j];\n        const intersection = wall.intersectionWith(new Linesegment(this.location, lidarRayTarget));\n        if (intersection) {\n          let distance = this.location.distanceTo(intersection) + gaussianNoise(this.lidarNoise);\n          for (let k = 0; k < this.lidarSamples; k++) {\n            let d2 = this.location.distanceTo(intersection) + gaussianNoise(this.lidarNoise);\n            distance = (distance + d2) / 2;\n          }\n          if (nearestIntersection) {\n            if (nearestIntersection.distance > distance) {\n              nearestIntersection = {\n                distance: distance,\n                intersection: intersection\n              };\n            }\n          } else {\n            nearestIntersection = {\n              distance: distance,\n              intersection: intersection\n            }\n          }\n        }\n      }\n\n      if (nearestIntersection) {\n        distances[currentRay] = nearestIntersection.distance;\n      }\n    }\n\n    return {\n      angles: angles,\n      distances: distances\n    }\n  }\n}\n\nexport {TurtleState};\n","function positionOverflowingValueFrom(pos, data, maxsize) {\n  if (pos < 0) {\n    pos += maxsize;\n  } else if (pos >= maxsize) {\n    pos -= maxsize;\n  }\n  return data[pos];\n}\n\nfunction derivativeOfInternal(data,maxsize,offset,i) {\n  const leftPos = positionOverflowingValueFrom(i - offset, data, maxsize);\n  const rightPos = positionOverflowingValueFrom(i + offset, data, maxsize);\n  if (leftPos && rightPos) {\n    return (rightPos - leftPos) / (offset + 1);\n  }\n  return undefined;\n}\n\nfunction derivativeOf(data,maxsize,offset) {\n  const result = []\n  for (let i = 0; i < maxsize; i++) {\n      // https://web.media.mit.edu/~crtaylor/calculator.html\n      /*const s1 = positionOverflowingValueFrom(i - 3, data, maxsize);\n      const s2 = positionOverflowingValueFrom(i - 2, data, maxsize);\n      const s3 = positionOverflowingValueFrom(i - 1, data, maxsize);\n      const s4 = positionOverflowingValueFrom(i + 1, data, maxsize);\n      const s5 = positionOverflowingValueFrom(i + 2, data, maxsize);\n      const s6 = positionOverflowingValueFrom(i + 3, data, maxsize);\n      if (s1 && s2 && s3 && s4 && s4 && s6) {\n        result[i] = (-s1 + 9 * s2 - 45 * s3 + 45 * s4 - 9 * s5 + s6) / 60;\n      } else {\n        result[i] = undefined;\n      }*/\n\n    let sum = undefined;\n    let samples = 0;\n    for (let j = offset; j >= 1; j--) {\n      const res = derivativeOfInternal(data, maxsize, j, i);\n      if (res) {\n        if (sum) {\n          sum += res;\n        } else {\n          sum = res;\n        }\n        samples++;\n      }\n    }\n    if (sum) {\n      result[i] = sum / samples;\n    } else {\n      result[i] = undefined;\n    }\n  }\n  return result;\n}\n\nexport {derivativeOf, positionOverflowingValueFrom};\n","import {Point, Linesegment} from \"./geom.js\";\nimport {gaussianNoise} from \"./noise.js\";\nimport {TurtleState} from \"./envsim.js\";\nimport {derivativeOf, positionOverflowingValueFrom} from \"./derivative.js\";\n\nconst canvas = document.getElementById(\"rendering\");\nconst context = canvas.getContext(\"2d\");\n\ncontext.lineWidth = 1;\ncontext.strokeStyle = 'black';\ncontext.fillStyle = 'black';\ncontext.scale(2, 2);\ncontext.translate(100, 100);\n\nconst turtleState = new TurtleState();\n\nconst turtleMindModel = {\n  particles: [\n    {\n      location: new Point(0, 0),\n      theta: turtleState.theta,\n      score: 1,\n      uncertainty: Math.pow(10, 2)\n    }\n  ],\n  estimatedState: function () {\n    var x = undefined;\n    var y = undefined;\n    var theta = undefined;\n    var uncertainty = undefined;\n    for (let i = 0; i < this.particles.length; i++) {\n      const particle = this.particles[i];\n      if (x) {\n        x = (x + particle.location.x) / 2;\n      } else {\n        x = particle.location.x;\n      }\n      if (y) {\n        y = (y + particle.location.y) / 2;\n      } else {\n        y = particle.location.y;\n      }\n      if (theta) {\n        theta = (theta + particle.theta) / 2;\n      } else {\n        theta = particle.theta;\n      }\n      if (uncertainty) {\n        uncertainty = (uncertainty + particle.uncertainty) / 2;\n      } else {\n        uncertainty = particle.uncertainty;\n      }\n    }\n    return {\n      location: new Point(x, y),\n      theta: theta,\n      uncertainty: uncertainty\n    }\n  },\n  features: [],\n  featureDetectionRadius: 3,\n\n  moveTurtleBy: function (dx, dy) {\n    const newParticles = [];\n    for (let i = 0; i < this.particles.length; i++) {\n      const particle = this.particles[i];\n      particle.location.translate(dx + gaussianNoise(3), dy + gaussianNoise(3));\n      particle.uncertainty = Math.pow(10, 2)\n    }\n    this.particles = this.particles.concat(newParticles);\n  },\n\n  rotateTurtle: function (angle) {\n    const newParticles = [];\n    for (let i = 0; i < this.particles.length; i++) {\n      const particle = this.particles[i];\n      particle.theta += angle;\n      particle.uncertainty = Math.pow(10, 2)\n    }\n    this.particles = this.particles.concat(newParticles);\n  },\n  updateParticleState: function (detectedFeatures) {\n    const estimatedState = turtleMindModel.estimatedState();\n\n    // If we do not have features, we initially add the found one to our map\n    if (this.features.length === 0) {\n      for (let i = 0; i < detectedFeatures.length; i++) {\n        const feature = detectedFeatures[i];\n        this.features.push({\n            uncertainty: Math.pow(10, 2),\n            location: estimatedState.location.polarProjection(feature.angle + estimatedState.theta, feature.distance)\n        });\n      }\n    } else {\n      // Now comes the tricky part: we evaluate the found features against\n      // every particle and verify the expectations\n      for (let i = 0; i < this.particles.length; i++) {\n        const particle = this.particles[i];\n        particle.score = 0;\n        for (let j = 0; j < this.features.length; j++) {\n          const expectedFeature = this.features[j];\n\n          // Now we check, if there is such a feature\n          for (let k = 0; k < detectedFeatures.length; k++) {\n            const detectedFeature = detectedFeatures[k];\n\n            const featureProjection = new Point(0, 0).polarProjection(detectedFeature.angle + particle.theta, detectedFeature.distance);\n\n            // This is what we have measured\n            const measuredFeaturePosition = featureProjection.translate(particle.location.x, particle.location.y);\n\n            context.beginPath();\n            context.strokeStyle = 'gray';\n            context.fillStyle = 'gray';\n            context.arc(56 + measuredFeaturePosition.x, 200 + measuredFeaturePosition.y, 8, 0, 2 * Math.PI);\n            context.stroke();\n            context.closePath();\n\n            const distance = measuredFeaturePosition.distanceTo(expectedFeature.location);\n\n            if (distance < 10) {\n              detectedFeature.identified = true;\n\n              // This is what we have found\n              context.beginPath();\n              context.strokeStyle = 'blue';\n              context.fillStyle = 'blue';\n              context.arc(56 + measuredFeaturePosition.x, 200 + measuredFeaturePosition.y, 6, 0, 2 * Math.PI);\n              context.stroke();\n              context.closePath();\n\n              // Maybe a match, the particle gets a hit point\n              particle.score += 1;\n\n              //\n              // Kalman filter\n              //\n\n              // Previous state, distance to feature\n              const distanceToFeature = expectedFeature.location.distanceTo(particle.location);\n\n              // We calculate the Kalman gain\n              const kg = estimatedState.uncertainty / (estimatedState.uncertainty + detectedFeature.uncertainty);\n\n              // Uncertainty update\n              particle.uncertainty = (1 - kg) * estimatedState.uncertainty;\n\n              // Estimate the new distance based on previous state and current measurement\n              const updatedNewDistance = distanceToFeature + kg * (detectedFeature.distance - distanceToFeature);\n\n              const oldLocation = particle.location;\n\n              // Backprojection of new distance from feature to get the new estimated position\n              particle.location = expectedFeature.location.polarProjection(detectedFeature.angle + particle.theta + 180, updatedNewDistance);\n              expectedFeature.location = oldLocation.polarProjection(detectedFeature.angle + particle.theta, updatedNewDistance);\n            }\n          }\n        }\n      }\n      // We calculate the mean score\n      var meanScore = undefined;\n      for (let i = 0; i < this.particles.length; i++) {\n        if (meanScore) {\n          meanScore = (meanScore + this.particles[i].score) / 2;\n        } else {\n          meanScore = this.particles[i].score;\n        }\n      }\n\n      // We are done here, now we evaluate dead particles\n      this.particles = this.particles.filter(function (value, index, arr) {\n        if (value.score >= meanScore) {\n          return true;\n        } else {\n          console.log(\"Particle \" + index + \" got score \" + value.score + \" from \" + detectedFeatures.length + \" and will be removed!\");\n          return false;\n        }\n      });\n    }\n  }\n};\n\nfunction polarLine(location, angle, length, color) {\n  const rayTarget = location.polarProjection(angle, length);\n  context.strokeStyle = color;\n  context.fillStyle = color;\n  context.beginPath();\n  context.moveTo(location.x, location.y);\n  context.lineTo(rayTarget.x, rayTarget.y);\n  context.stroke();\n  context.closePath();\n}\n\nfunction renderData(xp, yp, color, data, size, shiftOffset, scaleFactor, caption, height) {\n\n  for (let i = 0; i < size; i++) {\n\n    const dataPoint = data[i];\n    if (dataPoint) {\n\n      const drawXPosition = xp + ((i + shiftOffset) % size);\n      const drawYPositionStart = yp;\n      const drawYPositionEnd = drawYPositionStart + dataPoint * scaleFactor;\n\n      context.beginPath();\n      context.strokeStyle = color;\n      context.fillStyle = color;\n\n      context.moveTo(drawXPosition, drawYPositionStart);\n      context.lineTo(drawXPosition, drawYPositionEnd);\n\n      context.stroke();\n      context.closePath();\n    }\n  }\n\n  context.save();\n\n  context.beginPath();\n  context.strokeStyle = 'black';\n  context.fillStyle = 'black';\n\n  context.moveTo(xp, yp - height);\n  context.lineTo(xp, yp + height);\n\n  context.translate(xp, yp);\n  context.rotate(-Math.PI / 2);\n  context.textAlign = 'center';\n  context.font = \"8px Arial\";\n  context.fillText(caption, 0, -5);\n\n  context.stroke();\n  context.closePath();\n\n  context.restore();\n}\n\nvar dataBlob = undefined;\n\nfunction drawSimulation() {\n\n  context.clearRect(-100, -100, 1000, 1000);\n\n  // Render reality\n  context.strokeStyle = 'black';\n  context.fillStyle = 'black';\n  context.textAlign = 'left';\n  context.font = \"8px Arial\";\n  context.fillText('Reality', -20, -20);\n\n  // Draw the walls\n  context.strokeStyle = 'black';\n  context.fillStyle = 'black';\n  context.beginPath();\n  for (let i = 0; i < turtleState.walls.length; i++) {\n    const wall = turtleState.walls[i];\n    context.moveTo(wall.a.x, wall.a.y);\n    context.lineTo(wall.b.x, wall.b.y);\n  }\n  context.stroke();\n  context.closePath();\n\n  // Draw the turtle\n  context.beginPath();\n  context.strokeStyle = 'gray';\n  context.fillStyle = 'gray';\n  context.arc(turtleState.location.x, turtleState.location.y, 8, 0, 2 * Math.PI);\n  context.stroke();\n  context.closePath();\n\n  polarLine(turtleState.location, turtleState.theta, 20, 'green');\n\n  // Render turtles model\n  context.strokeStyle = 'black';\n  context.fillStyle = 'black';\n  context.textAlign = 'left';\n  context.font = \"8px Arial\";\n  context.fillText('Turtles model no.F. = ' + turtleMindModel.features.length + \", no. P = \" + turtleMindModel.particles.length, -20, 120);\n\n  for (let i = 0; i < turtleMindModel.particles.length; i++) {\n    const particle = turtleMindModel.particles[i];\n    context.beginPath();\n    context.strokeStyle = 'gray';\n    context.fillStyle = 'gray';\n    context.arc(particle.location.x + 56, particle.location.y + 200, 8, 0, 2 * Math.PI);\n    context.stroke();\n    context.closePath();\n    polarLine(new Point(particle.location.x + 56, particle.location.y + 200), particle.theta, 20, 'green');\n\n    context.strokeStyle = 'black';\n    context.fillStyle = 'black';\n    context.textAlign = 'left';\n    context.font = \"8px Arial\";\n    context.fillText('Uncertainty:', particle.location.x + 46, particle.location.y + 170);\n    context.fillText(particle.uncertainty.toPrecision(4), particle.location.x + 46, particle.location.y + 180);\n  }\n\n  for (let i = 0; i < turtleMindModel.features.length; i++) {\n    const feature = turtleMindModel.features[i];\n    context.beginPath();\n    context.strokeStyle = 'red';\n    context.fillStyle = 'red';\n    context.arc(feature.location.x - 1 + 56, feature.location.y -1 + 200, 3, 0, 2 * Math.PI);\n    context.stroke();\n    context.closePath();\n  }\n\n  const lidarFrame = turtleState.lidarFrame();\n\n  const currentRay = lidarFrame.angles.length;\n  const currentFrame = lidarFrame.distances;\n  const angles = lidarFrame.angles;\n\n  const maxNumScans = 360 / turtleState.lidarMinResolution;\n  const rotationOffset = maxNumScans / 2;\n\n  for (let i = 0; i < currentRay; i += 1) {\n\n    const lidarRayTarget = turtleState.location.polarProjection(i + turtleState.theta, turtleState.lidarLength);\n\n    const distance = currentFrame[i];\n    if (distance) {\n      const wallHitPoint = turtleState.location.polarProjection(i + turtleState.theta, distance);\n\n      context.beginPath();\n      context.strokeStyle = 'CadetBlue';\n      context.fillStyle = 'CadetBlue';\n      context.arc(wallHitPoint.x, wallHitPoint.y, 2, 0, 2 * Math.PI);\n      context.stroke();\n      context.closePath();\n\n      context.beginPath();\n      if (currentRay === 0) {\n        context.strokeStyle = 'green';\n        context.fillStyle = 'green';\n      } else {\n        context.strokeStyle = 'CadetBlue';\n        context.fillStyle = 'CadetBlue';\n      }\n\n      const scanProfileX = 200 + ((i + rotationOffset) % maxNumScans);\n      const scanProfileYStart = 50;\n      const scanProfileYEnd = scanProfileYStart - distance;\n\n      context.moveTo(scanProfileX, scanProfileYStart);\n      context.lineTo(scanProfileX, scanProfileYEnd);\n\n      context.stroke();\n      context.closePath();\n\n    } else {\n\n      context.strokeStyle = 'rgba(128,128,128,0.05)';\n      context.fillStyle = 'rgba(128,128,128,0.05)';\n      context.beginPath();\n      context.moveTo(turtleState.location.x, turtleState.location.y);\n      context.lineTo(lidarRayTarget.x, lidarRayTarget.y);\n      context.stroke();\n      context.closePath();\n    }\n  }\n\n  context.save();\n  context.beginPath();\n  context.strokeStyle = 'black';\n  context.fillStyle = 'black';\n  context.moveTo(200, 50);\n  context.lineTo(200, 50 - 120);\n  context.translate(200, 50);\n  context.rotate(-Math.PI / 2);\n  context.textAlign = 'center';\n  context.font = \"8px Arial\";\n  context.fillText('Lidar distance', 60, -5);\n  context.stroke();\n  context.closePath();\n  context.restore();\n\n  const rateOfChanges1st = derivativeOf(currentFrame, currentRay, turtleState.edgeDetectionThreshold);\n  const rateOfChanges2nd = derivativeOf(rateOfChanges1st, currentRay, turtleState.edgeDetectionThreshold);\n\n  // Render derivatives\n  renderData(200, 90, 'DarkSlateGrey', rateOfChanges1st, maxNumScans, rotationOffset, 5, '1st derivative', 20);\n  renderData(200, 160, 'DarkSlateGrey', rateOfChanges2nd, maxNumScans, rotationOffset, 20, '2nd derivative',20);\n\n  const detectedFeatures = [];\n\n  var csv = 'Angle;Distance;1st dvt;2nd dvt;Feature Detected\\n';\n\n  // Check for maxima and sharp edges\n  for (let i = 0; i < currentRay; i++) {\n    const current1stValue = positionOverflowingValueFrom(i, rateOfChanges1st, maxNumScans);\n    const next1stValue = positionOverflowingValueFrom(i + 1, rateOfChanges1st, maxNumScans);\n\n    const current2ndValue = positionOverflowingValueFrom(i, rateOfChanges2nd, maxNumScans);\n\n    var featureDetected = false;\n    if (current1stValue && next1stValue && current2ndValue) {\n      if ((current1stValue < 0 && next1stValue >= 0) || (current1stValue >=0 && next1stValue < 0)) {\n        // Sign change\n        if (Math.abs(current2ndValue) > 0.1) {\n          featureDetected = true;\n        }\n      }\n    }\n\n    csv+= '' + i + ';';\n    if (currentFrame[i]) {\n      csv+=Math.round(currentFrame[i] * 100);\n    }\n    csv+=';';\n    if (rateOfChanges1st[i]) {\n      csv+=Math.round(rateOfChanges1st[i] * 100);\n    }\n    csv+=';';\n    if (rateOfChanges2nd[i]) {\n      csv+=Math.round(rateOfChanges2nd[i] * 100);\n    }\n    csv+=';';\n    if (featureDetected)  {\n      csv+='Feature';\n    }\n    csv+='\\n';\n\n    const distance = currentFrame[i];\n    if (featureDetected && distance) {\n\n      const angle = angles[i];\n      const featureLocation = turtleState.location.polarProjection(angle, distance);\n\n      detectedFeatures.push({\n        angle: angle - turtleState.theta,\n        distance: distance,\n        uncertainty: Math.pow(5, 2)\n      });\n\n      // Mark Feature on the Map\n      context.beginPath();\n      context.strokeStyle = 'red';\n      context.fillStyle = 'red';\n      context.arc(featureLocation.x, featureLocation.y, 2, 0, 2 * Math.PI);\n      context.stroke();\n      context.closePath();\n\n      context.strokeStyle = 'lightgray';\n      context.fillStyle = 'lightgray';\n      context.beginPath();\n      context.moveTo(turtleState.location.x, turtleState.location.y);\n      context.lineTo(featureLocation.x, featureLocation.y);\n      context.stroke();\n      context.closePath();\n\n      // Mark Feature in Lidar data\n      let scanProfileX = 200 + ((i + rotationOffset) % maxNumScans);\n      let scanProfileYStart = 90;\n      let scanProfileYEnd = scanProfileYStart - rateOfChanges1st[i];\n\n      context.beginPath();\n      context.strokeStyle = 'red';\n      context.fillStyle = 'red';\n      context.arc(scanProfileX, scanProfileYEnd, 2, 0, 2 * Math.PI);\n      context.stroke();\n      context.closePath();\n\n      // Mark Feature in 1st derivative data\n      scanProfileX = 200 + ((i + rotationOffset) % maxNumScans);\n      scanProfileYStart = 50;\n      scanProfileYEnd = scanProfileYStart - currentFrame[i];\n\n      context.beginPath();\n      context.strokeStyle = 'red';\n      context.fillStyle = 'red';\n      context.arc(scanProfileX, scanProfileYEnd, 2, 0, 2 * Math.PI);\n      context.stroke();\n      context.closePath();\n    }\n  }\n\n  dataBlob = new Blob([csv], {type: 'text/csv'});\n  const element = document.getElementById('download');\n  element.href = window.URL.createObjectURL(dataBlob);\n  element.dowload = 'snapshot.csv';\n\n  turtleMindModel.updateParticleState(detectedFeatures);\n}\n\nfunction callback() {\n  drawSimulation();\n  window.requestAnimationFrame(callback);\n}\n\nwindow.requestAnimationFrame(callback);\n\nwindow.addEventListener(\"keydown\", function(event) {\n  if (event.key === \"ArrowUp\") {\n\n    const dx = Math.cos(Math.PI / 180 * turtleState.theta) * 3;\n    const dy = Math.sin(Math.PI / 180 * turtleState.theta) * 3;\n\n    turtleState.location.translate(dx, dy);\n\n    turtleMindModel.moveTurtleBy(dx, dy)\n  }\n  if (event.key === \"ArrowDown\") {\n    const dx = Math.cos(Math.PI / 180 * turtleState.theta) * -3;\n    const dy =  Math.sin(Math.PI / 180 * turtleState.theta) * -3;\n\n    turtleState.location.translate(dx, dy);\n\n    turtleMindModel.moveTurtleBy(dx, dy)\n  }\n  if (event.key === \"ArrowLeft\") {\n    turtleState.theta -= 2;\n\n    turtleMindModel.rotateTurtle(-2);\n  }\n  if (event.key === \"ArrowRight\") {\n    turtleState.theta += 2;\n\n    turtleMindModel.rotateTurtle(2);\n  }\n});\n"]}